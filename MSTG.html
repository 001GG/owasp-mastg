<h1 id="section"></h1>
<p><img src="images/OWASP_logo.png" alt="OWASP LOGO" /></p>
<h1 id="mobile-application-security-verification-standard">Mobile Application Security Verification Standard</h1>
<p>[date]</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<h2 id="about-the-standard">About the Standard</h2>
<p>The Mobile Application Security Verification Standard is a list of security requirements for mobile applications that can be used by architects, developers, testers, security professionals, and consumers to define what a secure mobile application is.</p>
<h2 id="copyright-and-license">Copyright and License</h2>
<p><img src="images/license.png" alt="license" /><br />
Copyright © 2016 The OWASP Foundation. This document is released under the Creative Commons Attribution ShareAlike 3.0 license. For any reuse or distribution, you must make clear to others the license terms of this work.</p>
<table>
<thead>
<tr class="header">
<th>Project Leads</th>
<th>Lead Authors</th>
<th>Contributors and Reviewers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bernhard Mueller, Sven Schleier</td>
<td>Stephen Corbiaux, Bernhard Mueller, Sven Schleier, Abdessamad Temmar, Stephanie Vanroelen, Gerhard Wagner, Jeroen Willemsen</td>
<td>Davide Cioccia, Shiv Patel, Anant Shrivastava, Bernard Wagner</td>
</tr>
</tbody>
</table>
<h1 id="testing-processes-and-techniques">Testing Processes and Techniques</h1>
<h2 id="black-box-testing">Black-box Testing</h2>
<h2 id="white-box-testing">White-box Testing</h2>
<h2 id="static-analysis">Static Analysis</h2>
<h2 id="dynamic-analysis">Dynamic Analysis</h2>
<h2 id="tampering-and-reverse-engineering">Tampering and Reverse Engineering</h2>
<h2 id="assessing-software-protections">Assessing Software Protections</h2>
<p>Whether we’re talking about malware, banking apps, or mobile games: They all use similar anti-reversing strategies made from the same building blocks. This includes defenses against debuggers, tamper proofing of application files and memory, and verifying the integrity of the environment. The question is, how do we verify that the defenses, taken together, are “good enough” to provide the desired level of protection? In the MASVS and MSTG, we tackle this question by defining sets of criteria for obfuscations and functional (programmatic) defenses, as well as testing processes that can be used for manual verification.</p>
<p>On the highest level, we classify reverse engineering defenses into two categories: Functional defenses and obfuscations. Both are used in tandem to achieve resiliency. Table 1 gives an overview of the categories and sub-categories as they appear in the guide.</p>
<table>
<thead>
<tr class="header">
<th>Functional Defenses</th>
<th>Obfuscations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>Prevent, or react to, actions of the reverse engineer</em></td>
<td><em>Modify code and/or data to make it less comprehensible</em></td>
</tr>
<tr class="even">
<td>Preventive: Functions that aim to prevent likely actions of the reverse engineer. As an example, an app may an operating system API to prevent debuggers from attaching to the process. Reactive: Features that aim to detect, and respond to, tools or actions of the reverse engineer. For example, an app could terminate when it suspects being run in an emulator, or change its behavior in some way a debugger is attached.</td>
<td>Modifications that are usually applied during the build process to the source code, binary, intermediate representation of the code, or other elements such as data or executable headers. The goal is to transform the code and data so it becomes more difficult to comprehend for human adversaries while still performing the desired function. Obfuscating transformations change the representation of the code and data, but do not exhibit behavior of their own (i.e. they don’t actively interfere with the actions of the reverse engineer).</td>
</tr>
<tr class="odd">
<td>1. Immediate response</td>
<td>1. Strip meaningful information</td>
</tr>
<tr class="even">
<td>2. Delayed response (stealth)</td>
<td>2. Increase complexity</td>
</tr>
<tr class="odd">
<td></td>
<td>3. Inhibit reverse engineering processes and tools</td>
</tr>
</tbody>
</table>
<h3 id="functional-defense-requirements">Functional defense requirements</h3>
<p>Functional defenses are programmatic features that aim to detect, and respond to, tools or actions of the reverse engineer. For example, an app could terminate when it suspects being run in an emulator, or change its behavior in some way a debugger is attached. When combined with obfuscation, multiple defenses add up to make the life of the reverse engineer as difficult as possible.</p>
<p>In the MASVS and MSTG, we define five defensive categories, each of which corresponds to a process used by reverse engineers (Figure 2). The MASVS defines the minimum amount of protection that must exist in each category.</p>
<p><img src="https://github.com/OWASP/owasp-mstg/blob/master/Document/images/reversing-processes.png" title="Reverse engineering processes" alt="Reverse engineering processes" /></p>
<p>For example, MASVS L2 requires an app to implement a simple form protection in the categories “environmental manipulation” and “debugging”. An app may pass as long as it implements any form of detection, no matter the specific implementation. MASVS L3 ups the ante by adding requirements for all five categories:</p>
<ul>
<li>8.6: &quot;Verify that the app implements two or more functionally independent methods of root detection and responds to the presence of a rooted device either by alerting the user or terminating the app.&quot;</li>
<li>8.7: &quot;Verify that the app implements multiple defenses that result in strong resiliency against debugging. All available means of debugging must be covered (e.g. JDWP and native).&quot;</li>
<li>8.8: &quot;Verify that the app detects and responds to tampering with executable files and critical data.&quot;</li>
<li>8.9: &quot;Verify that the app detects the presence of widely used reverse engineering tools, such as code injection tools, hooking frameworks and debugging servers.&quot;</li>
<li>8.10: &quot;Verify that the app detects whether it is run inside an emulator using any method, and responds by terminating or malfunctioning when an emulator is detected.&quot;</li>
<li>8.11: &quot;Verify that the app detects modifications of process memory, including relocation table patches and injected code.&quot;</li>
</ul>
<p>Basic requirements, such as 8.8 and 8.9, can be verified using either black-box or white-box testing (see the respective test cases for details). The requirement for <em>strong</em> resiliency in the debugging category (V8.7) will be discussed in the following sections.</p>
<p>(TODO)</p>
<h3 id="obfuscation-requirements">Obfuscation requirements</h3>
<p><img src="https://github.com/OWASP/owasp-mstg/blob/master/Document/images/obfuscation-model.png" title="Reverse engineering processes" alt="Obfuscation model" /></p>
<h4 id="tier-1-strip-meaningful-information">Tier 1: Strip Meaningful Information</h4>
<p>Compiled programs often retain explanative information that is helpful for the reverse engineer, but isn’t actually needed for the program to run. Debugging symbols that map machine code or byte code to line numbers, function names and variable names are an obvious example.<br />
For instance, class files generated with the standard Java compiler include the names of classes, methods and fields, making it trivial to reconstruct the source code. ELF and Mach-O binaries have a symbol table that contains debugging information, including the names of functions, global variables and types used in the executable.<br />
Stripping this information makes a compiled program less intelligible while fully preserving its functionality. Possible methods include removing tables with debugging symbols, or renaming functions and variables to random character combinations instead of meaningful names. This process sometimes reduces the size of the compiled program and doesn’t affect its runtime behavior.</p>
<h4 id="tier-2-obfuscate-control-flow-and-data">Tier 2: Obfuscate control flow and data</h4>
<p>The second type of obfuscations aims to hide the semantics of a computation by computing the same function in a more complicated way, or encoding sensitive data in ways that are not easily comprehensible. Provided that the adversary has no prior knowledge about the obfuscation parameters applied, these obfuscations increase the reverse engineering effort even for an adversary with full visibility of the execution trace. Obfuscation in this category have the following properties:</p>
<ul>
<li>The size and performance penalty can be sizable (scales with the obfuscation settings)</li>
<li>De-obfuscation requires advanced methods and/or custom tools</li>
</ul>
<p>A simple example for this kind of obfuscations are opaque predicates. Opaque predicates are redundant code branches added to the program that always execute the same way, which is known a priori to the programmer but not to the analyzer. For example, a statement such as if (1 + 1) = 1 always evaluates to false, and thus always result in a jump to the same location. Opaque predicates can be constructed in ways that make them difficult to identify and remove in static analysis.<br />
Some types of obfuscation that fall into this category are:</p>
<ul>
<li>Pattern-based obfuscation, when instructions are replaced with more complicated instruction sequences</li>
<li>Control flow obfuscation</li>
<li>Control flow flattening</li>
<li>Function Inlining</li>
<li>Data encoding and reordering</li>
<li>Variable splitting</li>
<li>Virtualization</li>
<li>White-box cryptography</li>
</ul>
<h4 id="tier-3-inhibit-reverse-engineering-processes-and-tools">Tier 3: Inhibit Reverse Engineering Processes and Tools</h4>
<p>The third category of transformations includes tricks that make static analysis more difficult, but do not transform the obfuscated computation per se. That is, the instructions that eventually compute the obfuscated function(s) remain more or less unchanged. Examples for this kind of transformations includes simple packing and encryption of large code blocks and manipulations of executable headers.<br />
In contrast to “type 2” obfuscations, transformations in this category have the following properties:</p>
<ul>
<li>The size and performance penalty is neglibigle;</li>
<li>De-obfuscation is relatively trivial, and can be accomplished with standard tools without scripting or customization.</li>
</ul>
<p>In general, type 3 obfuscations are a good way to achieve basic levels of reverse engineering protection without causing too much impact on size on performance. They can be used to deter less dedicated adversaries, and to add additional layers of resiliency once type 1 and 2 obfuscations have been applied.</p>
<h2 id="android">Android</h2>
<h3 id="white-box-testing-1">White-box Testing</h3>
<h3 id="black-box-testing-1">Black-box Testing</h3>
<h3 id="reverse-engineering-and-tampering">Reverse Engineering and Tampering</h3>
<h3 id="resiliency-testing">Resiliency Testing</h3>
<h2 id="ios">iOS</h2>
<h3 id="white-box-testing-2">White-box Testing</h3>
<h3 id="black-box-testing-2">Black-box Testing</h3>
<h3 id="reverse-engineering-and-tampering-1">Reverse Engineering and Tampering</h3>
<p>(TODO)</p>
<h3 id="resiliency-testing-1">Resiliency Testing</h3>
<p>(TODO)</p>
<h1 id="testing-data-storage">Testing Data Storage</h1>
<h2 id="overview">Overview</h2>
<p>[Describe what this chapter is about.]</p>
<h2 id="test-cases">Test Cases</h2>
<h3 id="omtg-datast-001-1-test-for-system-credentials-storage-features">OMTG-DATAST-001-1: Test for system credentials storage features</h3>
<p>Mobile operating systems offer different native functions to store sensitive information like credentials and keys encrypted within the device. In case credentials or keys needs to be stored, several best practices available on the OS level should be applied to make it harder for attackers to retrieve these information.</p>
<p>The following tasks should be done when analysing an App:</p>
<ul>
<li>Identify keys and passwords in the App, e.g. entered by the users, sent back by the endpoint, shipped within the App and how this sensitive data is processed locally.</li>
<li>Decide with the developers if this sensitive stored information locally is needed and if not, how it can be removed or moved to the server (endpoint).</li>
</ul>
<h4 id="detailed-guides">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-001-1">OMTG-DATAST-001-1 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-001">OMTG-DATAST-001 iOS</a></li>
</ul>
<h4 id="references">References</h4>
<h5 id="owasp-masvs-v2.1-data-storage-and-privacy-requirements">OWASP MASVS: V2.1: Data Storage and Privacy requirements:</h5>
<ul>
<li>Verify that system credential storage facilities are used appropriately to store sensitive data, such as user credentials or cryptographic keys.</li>
</ul>
<h5 id="owasp-mobile-top-10">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe">CWE</h5>
<ul>
<li>CWE-311 - Missing Encryption of Sensitive Data</li>
<li>CWE-312 - Cleartext Storage of Sensitive Information</li>
<li>CWE-522 - Insufficiently Protected Credentials</li>
<li>CWE-922 - Insecure Storage of Sensitive Information</li>
</ul>
<h3 id="omtg-datast-001-2-test-for-sensitive-data-disclosure-in-local-storage"><a name="OMTG-DATAST-001-2"></a>OMTG-DATAST-001-2: Test for Sensitive Data Disclosure in Local Storage</h3>
<p>The credo for saving data can be summarized quite easy: Public data should be available for everybody, but sensitive and private data needs to be protected or not stored in the first place on the device itself.<br />
This vulnerability can have many consequences, like disclosure of encryption keys that can be used by an attacker to decrypt information. More generally speaking an attacker might be able to identify these information to use it as a basis for other attacks like social engineering (when PII is disclosed), session hijacking (if session information or a token is disclosed) or gather information from apps that have a payment option in order to attack it.</p>
<p>This vulnerability occurs when sensitive data is not properly protected by an app when persistently storing it. The app might be able to store it in different places, for example locally on the device or on an external SD card.<br />
When trying to exploit this kind of issues, consider that there might be a lot of information processed and stored in different locations. It is important to identify at the beginning what kind of information is processed by the mobile application and keyed in by the user and what might be interesting and valuable for an attacker (e.g. passwords, credit card information).</p>
<h4 id="detailed-guides-1">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-001-2">OMTG-DATAST-001-2 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-001">OMTG-DATAST-001 iOS</a></li>
</ul>
<h4 id="references-1">References</h4>
<h5 id="owasp-masvs-v2.1-data-storage-and-privacy-requirements-1">OWASP MASVS: V2.1: Data Storage and Privacy requirements:</h5>
<ul>
<li>Verify that system credential storage facilities are used appropriately to store sensitive data, such as user credentials or cryptographic keys.</li>
</ul>
<h3 id="omtg-datast-002-testing-for-sensitive-data-disclosure-in-log-files">OMTG-DATAST-002: Testing for Sensitive Data Disclosure in Log Files</h3>
<p>There are many legit reasons to create log files on a mobile device, for example to keep track of crashes or errors that are stored locally when being offline and being sent to the application developer/company once online again or for usage statistics. However, logging sensitive data such as credit card number and session IDs might expose the data to attackers or malicious applications.<br />
Log files can be created in various ways on each of the different operating systems. The following list shows the mechanisms that are available on Android:</p>
<table>
<thead>
<tr class="header">
<th align="left">Android</th>
<th align="left">iOS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Log Class, .log[a-Z]</td>
<td align="left">NSLog Method</td>
</tr>
<tr class="even">
<td align="left">Logger Class</td>
<td align="left">printf-like function</td>
</tr>
<tr class="odd">
<td align="left">StrictMode</td>
<td align="left">NSAssert-like function</td>
</tr>
<tr class="even">
<td align="left">System.out/System.err.print</td>
<td align="left">Macro</td>
</tr>
</tbody>
</table>
<p>Classification of sensitive information can vary between different industries, countries and their laws and regulations. Therefore laws and regulations need to be known that are applicable to it and to be aware of what sensitive information actually is in the context of the App.</p>
<h4 id="detailed-guides-2">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-002">OMTG-DATAST-002 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-002">OMTG-DATAST-002 iOS</a></li>
</ul>
<h4 id="references-2">References</h4>
<h5 id="owasp-mobile-top-10-1">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-1">CWE</h5>
<ul>
<li>CWE-117: Improper Output Neutralization for Logs</li>
<li>CWE-532: Information Exposure Through Log Files</li>
<li>CWE-534: Information Exposure Through Debug Log Files</li>
</ul>
<h3 id="omtg-datast-003-test-that-no-sensitive-data-leaks-to-cloud-storage">OMTG-DATAST-003: Test that no sensitive data leaks to cloud storage</h3>
<p>[General description]</p>
<h4 id="detailed-guides-3">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-003">OMTG-DATAST-003 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-003">OMTG-DATAST-003 iOS</a></li>
</ul>
<h4 id="references-3">References</h4>
<h5 id="owasp-mobile-top-10-2">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-2">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-004-test-for-sending-sensitvie-data-to-3rd-parties">OMTG-DATAST-004: Test for sending sensitvie data to 3rd Parties</h3>
<p>Different 3rd party services are available that can be embedded into the App to implement different features. This features can vary from tracker services to monitor the user behaviour within the App, selling banner advertisements or to create a better user experience. Interacting with these services abstracts the complexity and neediness to implement the functionality on it’s own and to reinvent the wheel.<br />
The downside is that a developer doesn’t know in detail what code is executed via 3rd party libraries and therefore giving up visibility. Consequently it should be ensured that not more information as needed is sent to the service and that no sensitive information is disclosed.<br />
3rd party services are mostly implemented in two ways:</p>
<ul>
<li>By using a standalone library, like a Jar in an Android project that is getting included into the APK.</li>
<li>By using a full SDK.</li>
</ul>
<h4 id="detailed-guides-4">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-004">OMTG-DATAST-004 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-004">OMTG-DATAST-004 iOS</a></li>
</ul>
<h4 id="references-4">References</h4>
<h5 id="owasp-mobile-top-10-3">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-3">CWE</h5>
<ul>
<li>CWE-359 &quot;Exposure of Private Information ('Privacy Violation')&quot;: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-005-test-that-keyboard-cache-is-disabled-for-sensitive-data">OMTG-DATAST-005: Test that keyboard cache is disabled for sensitive data</h3>
<p>When keying in data into input fields, the software keyboard automatically suggests what data the user might want to key in. This feature can be very useful in messaging Apps to write text messages more efficient. For input fields that are asking for sensitive information like passwords or credit card data the keyboard cache might disclose sensitive information already when the input field is selected. This feature should therefore be disabled for input fields that are asking for sensitive information.</p>
<h4 id="detailed-guides-5">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-005">OMTG-DATAST-005 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-005">OMTG-DATAST-005 iOS</a></li>
</ul>
<h4 id="references-5">References</h4>
<h5 id="owasp-mobile-top-10-4">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-4">CWE</h5>
<ul>
<li>CWE-524: Information Exposure Through Caching</li>
</ul>
<h3 id="omtg-datast-006-test-that-clipboard-is-deactivated-for-sensitive-input-fields">OMTG-DATAST-006: Test that clipboard is deactivated for sensitive input fields</h3>
<p>[General description]</p>
<h4 id="detailed-guides-6">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-006">OMTG-DATAST-006 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-006">OMTG-DATAST-006 iOS</a></li>
</ul>
<h4 id="references-6">References</h4>
<h5 id="owasp-mobile-top-10-5">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-5">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-007-test-that-no-sensitive-data-is-exposed-via-ipc-mechanisms">OMTG-DATAST-007: Test that no sensitive data is exposed via IPC mechanisms</h3>
<p>[General description]</p>
<h4 id="detailed-guides-7">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-007">OMTG-DATAST-007 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-007">OMTG-DATAST-007 iOS</a></li>
</ul>
<h4 id="references-7">References</h4>
<h5 id="owasp-mobile-top-10-6">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-6">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-008-test-that-no-sensitive-data-is-exposed-via-the-user-interface-or-screenshots">OMTG-DATAST-008: Test that no sensitive data is exposed via the user interface or screenshots</h3>
<p>[General description]</p>
<h4 id="detailed-guides-8">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-008">OMTG-DATAST-008 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-008">OMTG-DATAST-008 iOS</a></li>
</ul>
<h4 id="references-8">References</h4>
<h5 id="owasp-mobile-top-10-7">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-7">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-009-test-for-sensitive-data-in-backups">OMTG-DATAST-009: Test for Sensitive Data in Backups</h3>
<p>[General description]</p>
<h4 id="detailed-guides-9">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-009">OMTG-DATAST-009 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-009">OMTG-DATAST-009 iOS</a></li>
</ul>
<h4 id="references-9">References</h4>
<ul>
<li>OWASP MASVS: V2-9: &quot;Verify that sensitive data does not leak to backups.&quot;</li>
<li><a href="https://cwe.mitre.org/data/definitions/530.html">CWE-530</a></li>
</ul>
<h3 id="omtg-datast-010-test-that-no-sensitive-data-leaks-when-backgrounded">OMTG-DATAST-010: Test that no sensitive data leaks when backgrounded</h3>
<p>Manufacturers want to provide device users an aesthetically pleasing effect when an application is entered or exited, hence they introduced the concept of saving a screenshot when the application goes into the background. This feature could potentially pose a security risk for an application, as the screenshot containing sensitive information (e.g. a screenshot of an email or corporate documents) is written to local storage, where it is recovered either by a rogue application on a jailbroken device, or by someone who steals the device.</p>
<h4 id="detailed-guides-10">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-010">OMTG-DATAST-010 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-010">OMTG-DATAST-010 iOS</a></li>
</ul>
<h4 id="references-10">References</h4>
<h5 id="owasp-mobile-top-10-8">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-8">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-011-test-for-sensitive-data-disclosure-in-process-memory">OMTG-DATAST-011: Test for Sensitive Data Disclosure in Process Memory</h3>
<p>Analyzing the memory can help to identify the root cause of different problems, like for example why an application is crashing, but can also be used to identify sensitive data. This section describes how to check for sensitive data and disclosure of data in general within the process memory.</p>
<p>To be able to investigate the memory of an application a memory dump needs to be created first or the memory needs to be viewed with real-time updates. This is also already the problem, as the application only stores certain information in memory if certain functions are triggered within the application. Memory investigation can of course be executed randomly in every stage of the application, but it is much more beneficial to understand first what the mobile application is doing and what kind of functionalities it offers and also make a deep dive into the decompiled code before making any memory analysis.<br />
Once sensitive functions are identified (like decryption of data) the investigation of a memory dump might be beneficial in order to identify sensitive data like a key or decrypted information.</p>
<h4 id="detailed-guides-11">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-011">OMTG-DATAST-011 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-011">OMTG-DATAST-011 iOS</a></li>
</ul>
<h4 id="references-11">References</h4>
<h5 id="owasp-mobile-top-10-9">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-9">CWE</h5>
<ul>
<li>CWE-316 - Cleartext Storage of Sensitive Information in Memory</li>
</ul>
<h3 id="omtg-datast-012-test-support-of-hardware-backed-keystore">OMTG-DATAST-012: Test support of Hardware-Backed Keystore</h3>
<p>[General description]</p>
<h4 id="detailed-guides-12">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-012">OMTG-DATAST-012 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-012">OMTG-DATAST-012 iOS</a></li>
</ul>
<h4 id="references-12">References</h4>
<h5 id="owasp-mobile-top-10-10">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-10">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-013-test-remote-locking-and-wiping">OMTG-DATAST-013: Test remote locking and wiping</h3>
<p>[General description]</p>
<h4 id="detailed-guides-13">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-013">OMTG-DATAST-013 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-013">OMTG-DATAST-013 iOS</a></li>
</ul>
<h4 id="references-13">References</h4>
<h5 id="owasp-mobile-top-10-11">OWASP Mobile Top 10</h5>
<h5 id="cwe-11">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-014-test-for-device-access-security-policy">OMTG-DATAST-014: Test for device access security policy</h3>
<p>[General description]</p>
<h4 id="detailed-guides-14">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-014">OMTG-DATAST-014 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-014">OMTG-DATAST-014 iOS</a></li>
</ul>
<h4 id="references-14">References</h4>
<h5 id="owasp-mobile-top-10-12">OWASP Mobile Top 10</h5>
<h5 id="cwe-12">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-015-test-for-usage-of-hardware-based-se-or-tee">OMTG-DATAST-015: Test for usage of hardware-based SE or TEE</h3>
<p>[General description]</p>
<h4 id="detailed-guides-15">Detailed Guides</h4>
<ul>
<li><a href="0x00a_OMTG-DATAST_Android.md#OMTG-DATAST-015">OMTG-DATAST-015 Android</a></li>
<li><a href="0x00b_OMTG-DATAST_iOS.md#OMTG-DATAST-015">OMTG-DATAST-015 iOS</a></li>
</ul>
<h4 id="references-15">References</h4>
<h5 id="owasp-mobile-top-10-13">OWASP Mobile Top 10</h5>
<h5 id="cwe-13">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h2 id="omtg-datast-001-1-test-for-system-credentials-storage-features-1"><a name="OMTG-DATAST-001-1"></a>OMTG-DATAST-001-1: Test for system credentials storage features</h2>
<h3 id="white-box-testing-3">White-box Testing</h3>
<p>Encryption operations should rely on solid and tested functions provided by the SDK. The following describes different “bad practices” that should be checked withi the source code:</p>
<ul>
<li>Check if simple bit operations are used, like XOR or Bit flipping to “encrypt” sensitive information like credentials or private keys that are stored locally. This should be avoided as the data can easily be recovered.</li>
<li>Check if keys are created or used without taking advantage of the Android onboard features like the <a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">KeyStore</a>.</li>
<li>Identify what kind of information is stored persistently and if credentials or keys are disclosed.</li>
</ul>
<p>When going through the source code it should be analyzed if native mechanisms that are offered by Android are applied to the identified sensitive information. Sensitive information should not be stored in clear text and should be encrypted. If sensitive information needs to be stored on the device itself, several functions/API calls are available to protect the data on the Android device by using the <strong>KeyChain</strong> and <strong>Keystore</strong>. The following controls should therefore be used:</p>
<ul>
<li>Check if a key pair is created within the App by looking for the class <code>KeyPairGenerator</code>.</li>
<li>Check that the application is using the KeyStore and Cipher mechanisms to securely store encrypted information on the device. Look for the pattern <code>import java.security.KeyStore</code>, <code>import javax.crypto.Cipher</code>, <code>import java.security.SecureRandom</code> and it’s usage.</li>
<li>The <code>store(OutputStream stream, char[] password)</code> function can be used to store the KeyStore to disk with a specified password. Check that the password provided is not hardcoded and is defined by user input as this should only be known to the user. Look for the pattern <code>.store(</code>.</li>
</ul>
<p>The code should also be analysed if sensitive data is used properly and securely:</p>
<ul>
<li>Sensitive information should not be stored for too long in the RAM (see also <a href="#OMTG-DATAST-011">OMTG-DATAST-011 - Testing for Sensitive Data Disclosure in Process Memory</a>).</li>
<li>Set variables that use sensitive information to null once finished.</li>
<li>Use immutable objects for sensitive data so it cannot be changed.</li>
</ul>
<h3 id="black-box-testing-3">Black-box Testing</h3>
<p>When targetting compiled Android applications, the best way to proceed is to first decompile them in order to obtain something close to the source code (<em><strong>see Decompiling Android App Guide - #TODO-Create a general guide that can bee referenced anywhere in the OMSTF</strong></em>). With the code in your hands you should then be able to inspect and verify if system credentials storage facilities are in place.</p>
<h3 id="remediation">Remediation</h3>
<p>If sensitive information (credentials, keys, PII, etc.) is needed locally on the device several best practices are offered by Android that should be used to store data securely instead of reinventing the wheel or leave it unencrypted on the device.</p>
<p>The following is a list of best practice used for secure storage of certificates and keys and sensitve data in general:</p>
<ul>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android KeyStore</a>: The KeyStore provides a secure system level credential storage. It is important to note that the credentials are not actually stored within the KeyStore. An app can create a new private/public key pair to encrypt application secrets by using the public key and decrypt the same by using the private key. The KeyStores is a secure container that makes it difficult for an attacker to retrieve the private key and guards the encrypted data. Nevertheless an attacker can access all keys on a rooted device in the folder <code>/data/misc/keystore/</code>. The Keystore is encrypted using the user’s own lockscreen pin/password, hence, when the device screen is locked the Keystore is unavailable. More information can be found here: <a href="http://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/" title="Use Android Keystore">how to use Android Keystore</a>.</li>
<li><a href="http://developer.android.com/reference/android/security/KeyChain.html" title="Android KeyChain">Android KeyChain</a>: The KeyChain class is used to store and retrieve private keys and their corresponding certificate (chain). The user will be prompted to set a lock screen PIN or password to protect the credential storage if it hasn’t been set, if something gets imported into the KeyChain the first time.</li>
<li>Encryption or decryption functions that were self implemented need to be avoided. Instead use Android implementations such as <a href="https://developer.android.com/reference/javax/crypto/Cipher.html" title="Cipher">Cipher</a>, <a href="https://developer.android.com/reference/java/security/SecureRandom.html" title="SecureRandom">SecureRandom</a> and <a href="https://developer.android.com/reference/javax/crypto/KeyGenerator.html" title="KeyGenerator">KeyGenerator</a>.<br />
</li>
<li>Username and password should not be stored on the device. Instead, perform initial authentication using the username and password supplied by the user, and then use a short-lived, service-specific authorization token (session token). If possible, use the <a href="https://developer.android.com/reference/android/accounts/AccountManager.html" title="AccountManager">AccountManager</a> class to invoke a cloud-based service and do not store passwords on the device.</li>
<li>As a security in depth measure code obfuscation should also be applied to the App, to make reverse engineering harder for attackers.</li>
</ul>
<h3 id="references-16">References</h3>
<ul>
<li><a href="http://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/" title="Use Android Keystore">How to use the Android Keystore to store passwords and other sensitive information</a></li>
<li><a href="http://developer.android.com/reference/android/security/KeyChain.html" title="Android KeyChain">Android KeyChain</a></li>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android KeyStore</a></li>
</ul>
<h2 id="omtg-datast-001-2-test-for-sensitive-data-disclosure-in-local-storage-1"><a name="OMTG-DATAST-001-2"></a>OMTG-DATAST-001-2: Test for Sensitive Data Disclosure in Local Storage</h2>
<h3 id="overview-1">Overview</h3>
<p><a href="http://developer.android.com/training/articles/security-tips.html#StoringData" title="StoringData">Storing data</a> is essential for many mobile applications, for example in order to keep track of user settings or data a user might has keyed in that needs to stored locally or offline. Data can be stored persistently by a mobile application in various ways on each of the different operating systems. The following table shows those mechanisms that are available on the Android platform:</p>
<ul>
<li>Shared Preferences</li>
<li>Internal Storage<br />
</li>
<li>External Storage<br />
</li>
<li>SQLite Databases</li>
</ul>
<p>The following examples shows snippets of code to demonstrate bad practices that discloses sensitive information and also shows the different mechanisms in Android to store data.</p>
<p>The following examples shows snippets of code to demonstrate bad practices that discloses sensitive information and also shows the different mechanisms in Android to store data.</p>
<h4 id="shared-preferences">Shared Preferences</h4>
<p><a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">SharedPreferences</a> is a common approach to store Key/Value pairs persistently in the filesystem by using a XML structure. Within an Activity the following code might be used to store sensitive information like a username and a password:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SharedPreferences sharedPref = <span class="fu">getSharedPreferences</span>(<span class="st">&quot;key&quot;</span>, MODE_WORLD_READABLE);
SharedPreferences.<span class="fu">Editor</span> editor = sharedPref.<span class="fu">edit</span>();
editor.<span class="fu">putString</span>(<span class="st">&quot;username&quot;</span>, <span class="st">&quot;administrator&quot;</span>);
editor.<span class="fu">putString</span>(<span class="st">&quot;password&quot;</span>, <span class="st">&quot;supersecret&quot;</span>);
editor.<span class="fu">commit</span>();</code></pre></div>
<blockquote>
<p>Please note that <code>MODE_WORLD_READABLE</code> and <code>MODE_WORLD_WRITEABLE</code> were deprecated in API 17. Although this may not affect newer devices, applications compiled with android:targetSdkVersion set prior to 17 may still be affected, if they run on OS prior to Android 4.2 (<code>JELLY_BEAN_MR1</code>).</p>
</blockquote>
<p>Once the activity is called, the file key.xml is created with the provided data. This code is violating several best practices.</p>
<ul>
<li>The username and password is stored in clear text in <code>/data/data/&lt;PackageName&gt;/shared_prefs/key.xml</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; <span class="kw">?&gt;</span>
<span class="kw">&lt;map&gt;</span>
  <span class="kw">&lt;string</span><span class="ot"> name=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>administrator<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;string</span><span class="ot"> name=</span><span class="st">&quot;password&quot;</span><span class="kw">&gt;</span>supersecret<span class="kw">&lt;/string&gt;</span>
<span class="kw">&lt;/map&gt;</span></code></pre></div>
<ul>
<li><code>MODE_WORLD_READABLE</code> allows all applications to access and read the content of <code>key.xml</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">root@hermes</span>:/data/data/sg.vp.owasp_mobile.myfirstapp/shared_prefs <span class="co"># ls -la</span>
<span class="kw">-rw-rw-r--</span> u0_a118 u0_a118    170 2016-04-23 16:51 key.xml</code></pre></div>
<h4 id="sqlite-databases-unencrypted">SQLite Databases (Unencrypted)</h4>
<p>SQLite is a SQL database that stores data to a text file. The Android SDK comes with built in classes to operate SQLite databases. The main package to manage the databases is android.database.sqlite.<br />
Within an Activity the following code might be used to store sensitive information like a username and a password:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SQLiteDatabase notSoSecure = <span class="fu">openOrCreateDatabase</span>(<span class="st">&quot;privateNotSoSecure&quot;</span>,MODE_PRIVATE,<span class="kw">null</span>);
notSoSecure.<span class="fu">execSQL</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,Password VARCHAR);&quot;</span>);
notSoSecure.<span class="fu">execSQL</span>(<span class="st">&quot;INSERT INTO Accounts VALUES(&#39;admin&#39;,&#39;AdminPass&#39;);&quot;</span>);
notSoSecure.<span class="fu">close</span>();</code></pre></div>
<p>Once the activity is called, the database file <code>privateNotSoSecure</code> is created with the provided data and the data is stored in clear text in <code>/data/data/&lt;PackageName&gt;/databases/privateNotSoSecure</code>.</p>
<p>There might be several files available in the databases directory, besides the SQLite database.</p>
<ul>
<li>Journal files: These are temporary files used to implement atomic commit and rollback capabilities in SQLite (see also <a href="https://www.sqlite.org/tempfiles.html" title="Journal files">tempfiles</a> ).</li>
<li>Lock files: The lock files are part of the locking and journaling mechanism designed to improve concurrency in SQLite and to reduce the writer starvation problem. You can read more here: <a href="https://www.sqlite.org/lockingv3.html" title="Lock Files">lockingv3</a>.</li>
</ul>
<p>Unencrypted SQLite databases should not be used to store sensitive information.</p>
<h4 id="sqlite-databases-encrypted">SQLite Databases (Encrypted)</h4>
<p>By using the library <a href="https://www.zetetic.net/sqlcipher/sqlcipher-for-android/" title="SQLCipher">SQLCipher</a> SQLite databases can be encrypted, by providing a password.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SQLiteDatabase secureDB = SQLiteDatabase.<span class="fu">openOrCreateDatabase</span>(database, <span class="st">&quot;password123&quot;</span>, <span class="kw">null</span>);
secureDB.<span class="fu">execSQL</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,Password VARCHAR);&quot;</span>);
secureDB.<span class="fu">execSQL</span>(<span class="st">&quot;INSERT INTO Accounts VALUES(&#39;admin&#39;,&#39;AdminPassEnc&#39;);&quot;</span>);
secureDB.<span class="fu">close</span>();</code></pre></div>
<p>If encrypted SQLite databases are used, check if the password is hardcoded in the source, stored in shared preferences or hidden somewhere else in the code or file system.<br />
A secure approach to retrieve the key, instead of storing it locally could be to either:</p>
<ul>
<li>Ask the user every time for a PIN or password to decrypt the database, once the App is opened (weak password or PIN is prone to Brute Force Attacks)</li>
<li>Store the key on the server and make it accessible via a Web Service (then the App can only be used when the device is online)</li>
</ul>
<h4 id="internal-storage">Internal Storage</h4>
<p>Files can be saved directly on the device's <a href="http://developer.android.com/guide/topics/data/data-storage.html#filesInternal" title="UsingInternalStorage">internal storage</a>. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.<br />
Within an Activity the following code might be used to store sensitive information in the variable string persistently to the internal storage:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">FileOutputStream fos = <span class="kw">null</span>;
<span class="kw">try</span> {
   fos = <span class="fu">openFileOutput</span>(FILENAME, Context.<span class="fu">MODE_PRIVATE</span>);
   fos.<span class="fu">write</span>(string.<span class="fu">getBytes</span>());
   fos.<span class="fu">close</span>();
} <span class="kw">catch</span> (FileNotFoundException e) {
   e.<span class="fu">printStackTrace</span>();
} <span class="kw">catch</span> (IOException e) {
   e.<span class="fu">printStackTrace</span>();
}</code></pre></div>
<p>The file mode need to be checked, to make sure that only the app itself has access to the file by using <code>MODE_PRIVATE</code>. Other modes like <code>MODE_WORLD_READABLE</code> (deprecated) and <code>MODE_WORLD_WRITEABLE</code> (deprecated) are more lax and can pose a security risk.</p>
<p>It should also be checked what files are read within the App by searching for the usage of class <code>FileInputStream</code>. Part of the internal storage mechanisms is also the cache storage. To cache data temporarily, functions like <code>getCacheDir()</code> can be used.</p>
<h4 id="external-storage">External Storage</h4>
<p>Every Android-compatible device supports a shared &quot;<a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal" title="UsingExternalStorage">external storage</a>&quot; that you can use to save files. This can be a removable storage media (such as an SD card) or an internal (non-removable) storage.<br />
Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer.<br />
Within an Activity the following code might be used to store sensitive information in the variable string persistently to the external storage:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">File file = <span class="kw">new</span> File (Environment.<span class="fu">getExternalFilesDir</span>(), <span class="st">&quot;password.txt&quot;</span>);
String password = <span class="st">&quot;SecretPassword&quot;</span>;
FileOutputStream fos;
    fos = <span class="kw">new</span> FileOutputStream(file);
    fos.<span class="fu">write</span>(password.<span class="fu">getBytes</span>());
    fos.<span class="fu">close</span>();</code></pre></div>
<p>Once the activity is called, the file is created with the provided data and the data is stored in clear text in the external storage.</p>
<p>It’s also worth to know that files stored outside the application folder (internal: <code>data/data/com.appname/files</code> or external: <code>/storage/emulated/0/Android/data/com.appname/files/</code>) will not be deleted when the user uninstall the application.</p>
<h3 id="white-box-testing-4">White-box Testing</h3>
<p>As already pointed out, there are several ways to store information within Android. Several checks should therefore be applied to the source code of an Android App, once decompiled.</p>
<ul>
<li>Check <code>AndroidManifest.xml</code> for permissions to read and write to external storage, like <code>uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</code></li>
<li>Check the source code for functions and API calls that are used for storing data:</li>
<li>Import the decompiled Java Files in an IDE of your choice (IntelliJ or Eclipse) or use grep on the command line to search for
<ul>
<li>file permissions like:</li>
<li><code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITABLE</code>. IPC files should not be created with permissions of <code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITABLE</code> unless it is required as any app would be able to read or write the file even though it may be stored in the app’s private data directory.</li>
<li>Classes and functions like:</li>
<li>Shared Preferences (Storage of key-value pairs)</li>
<li><code>FileOutPutStream</code> (Using Internal or External Storage)</li>
<li><code>getExternal*</code> functions (Using External Storage)</li>
<li><code>getWritableDatabase</code> function (return a SQLiteDatabase for writing)</li>
<li><code>getReadableDatabase</code> function (return a SQLiteDatabase for reading)</li>
<li><code>getCacheDir</code> and <code>getExternalCacheDirs</code> function (Using cached files)</li>
</ul></li>
</ul>
<h3 id="black-box-testing-4">Black-box Testing</h3>
<p>Install and use the App as it is intended. Afterwards check the following items:</p>
<ul>
<li>Check the files that are shipped with the mobile application once installed in /data/data/<AppName>/files in order to identify development, backup or simply old files that shouldn’t be in a production release.</li>
<li>Check if .db files are available, which are SQLite databases and if they contain sensitive information (usernames, passwords, keys etc.). SQlite databases can be accessed on the command line with sqlite3.</li>
<li>Check Shared Preferences that are stored as XML files in the shared_prefs directory of the App for sensitive information.</li>
<li>Check the file system permissions of the files in /data/data/<app name>. The permission should only allow rwx to the user and his group that was created for the app (e.g. u0_a82) but not to others. Others should have no permissions to files, but may have the executable flag to directories.</li>
</ul>
<h3 id="remediation-1">Remediation</h3>
<p>Usage of <code>MODE_WORLD_WRITEABLE</code> or <code>MODE_WORLD_READABLE</code> should generally be avoided for files. If data needs to be shared with other applications, a content provider should be considered. A content provider offers read and write permissions to other apps and can make dynamic permission grants on a case-by-case basis.</p>
<p>The usage of Shared Preferences or other mechanisms that are not able to protect data should be avoided to store sensitive information. SharedPreferences are insecure and not encrypted by default.</p>
<p>Do not use the external storage for sensitive data. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p>
<p>To provide additional protection for sensitive data, you might choose to encrypt local files using a key that is not directly accessible to the application. For example, a key can be placed in a <a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">KeyStore</a> and protected with a user password that is not stored on the device. While this does not protect data from a root compromise that can monitor the user inputting the password, it can provide protection for a lost device without file system encryption.</p>
<p><a href="https://github.com/scottyab/secure-preferences" title="SecurePreferences">“Secure-preferences</a>” can be used to encrypt the values stored within <a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">Shared Preferences</a>.</p>
<h3 id="references-17">References</h3>
<h4 id="info">Info</h4>
<ul>
<li><a href="http://developer.android.com/guide/topics/data/data-storage.html#filesInternal" title="UsingInternalStorage">Internal Storage</a></li>
<li><a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal" title="UsingExternalStorage">External Storage</a></li>
<li><a href="http://developer.android.com/training/articles/security-tips.html#StoringData" title="StoringData">Storing Data</a></li>
<li><a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">Shared Preferences</a></li>
<li><a href="https://www.zetetic.net/sqlcipher/sqlcipher-for-android/" title="SQLCipher">SQLCipher</a></li>
<li><a href="https://github.com/scottyab/secure-preferences" title="SecurePreferences">SecurePreferences</a></li>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android Keystore</a></li>
<li><a href="https://developer.android.com/training/basics/data-storage/index.html" title="AndroidStorage">Android Storage Documentation</a></li>
</ul>
<h4 id="tools">Tools</h4>
<ul>
<li><a href="https://github.com/google/enjarify" title="Enjarify">Enjarify</a></li>
<li><a href="https://github.com/skylot/jadx" title="JADX">JADX</a></li>
<li><a href="https://github.com/pxb1988/dex2jar" title="Dex2jar">Dex2jar</a></li>
<li><a href="http://developer.android.com/tools/help/lint.html" title="Lint">Lint</a></li>
<li><a href="http://www.sqlite.org/cli.html" title="Sqlite3">SQLite3</a></li>
</ul>
<h2 id="omtg-datast-002-testing-for-sensitive-data-disclosure-in-log-files-1"><a name="OMTG-DATAST-002"></a>OMTG-DATAST-002: Testing for Sensitive Data Disclosure in Log Files</h2>
<h3 id="white-box-testing-5">White-box Testing</h3>
<p>Check the source code for usage of Logging functions, by searching for the following terms:</p>
<ol>
<li>Function names like:</li>
</ol>
<ul>
<li><code>Log.d</code>, <code>Log.e</code>, <code>Log.i</code>, <code>Log.v</code>, <code>Log.w</code> and so on</li>
<li><code>Logger</code></li>
<li><code>StrictMode</code></li>
</ul>
<ol>
<li>Keywords and system output to identify non-standard log mechanisms like :</li>
</ol>
<ul>
<li>Logfile</li>
<li>logging</li>
<li><code>System.out.print</code> | <code>System.out.println</code></li>
</ul>
<h3 id="black-box-testing-5">Black-box Testing</h3>
<p>Use the mobile app extensively so that all functionality is at least triggered once.</p>
<ol>
<li>Identify the data directory of the application in order to look for log files (<code>/data/data/package_name</code>). Check if log data is generated by checking the application logs, as some mobile applications create and store their own logs in the data directory.<br />
</li>
<li>Many application developers use still <code>System.out.println()</code> or <code>printStackTrace()</code> instead of a proper logging class. Therefore the testing approach also needs to cover all output generated by the application during starting, running and closing of it and not only the output created by the log classes. In order to verify what data is written to <code>logfiles</code> and printed directly by using <code>System.out.println()</code> or <code>printStackTrace()</code> the code should be checked for these functions and the tool <a href="http://developer.android.com/tools/help/logcat.html" title="LogCat"><em>LogCat</em></a> can be used to check the output. Two different approaches are available to execute LogCat.</li>
</ol>
<ul>
<li>LogCat is already part of <em>Dalvik Debug Monitor Server</em> (DDMS) and is therefore built into Android Studio. Once the app is running and in debug mode, patterns can be defined in LogCat to reduce the log output of the app.</li>
</ul>
<p><img src="http://bb-conservation.de/sven/adb.png" alt="Log output in Android Studio" /></p>
<ul>
<li>LogCat can be executed by using adb in order to store the log output permanently.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># adb logcat &gt; logcat.log</span></code></pre></div>
<h3 id="remediation-2">Remediation</h3>
<p>Ensure logging statements are removed from the production release, as logs may be interrogated or readable by other applications. Tools like <strong><a href="http://proguard.sourceforge.net/" title="ProGuard">ProGuard</a></strong>, which is already included in Android Studio or <strong><a href="https://www.guardsquare.com/dexguard" title="DexGuard">DexGuard</a></strong> can be used to strip out logging portions in the code when preparing the production release. For example, to remove logging calls within an android application, simply add the following option in the <em>proguard-project.txt</em> configuration file of Proguard:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">-assumenosideeffects <span class="kw">class</span> android.<span class="fu">util</span>.<span class="fu">Log</span>
{
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">isLoggable</span>(java.<span class="fu">lang</span>.<span class="fu">String</span>, <span class="dt">int</span>);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">v</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">i</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">w</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">d</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">e</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">wtf</span>(...);
}</code></pre></div>
<p>Although the <code>android:debuggable=&quot;&quot;</code> flag can be bypassed by repacking the application, before shipping it, it is important to set the option <code>android:debuggable=&quot;false&quot;</code> in the <em>AndroidManifest.xml</em>.</p>
<h3 id="references-18">References</h3>
<h4 id="info-1">Info</h4>
<ul>
<li><a href="http://developer.android.com/reference/android/util/Log.html" title="ClassLogOverview">Overview of Class Log</a></li>
<li><a href="http://developer.android.com/tools/debugging/debugging-log.html" title="DebuggingLogsLogCat">Debugging Logs with LogCat</a></li>
</ul>
<h4 id="tools-1">Tools</h4>
<ul>
<li><a href="http://developer.android.com/tools/help/logcat.html" title="LogCat">LogCat</a></li>
<li><a href="http://proguard.sourceforge.net/" title="ProGuard">ProGuard</a></li>
<li><a href="https://www.guardsquare.com/dexguard" title="DexGuard">DexGuard</a></li>
<li><a href="https://github.com/google/android-classyshark" title="ClassyShark">ClassyShark</a></li>
</ul>
<h2 id="omtg-datast-003-test-that-no-sensitive-data-leaks-to-cloud-storage-1"><a name="OMTG-DATAST-003"></a>OMTG-DATAST-003: Test that no sensitive data leaks to cloud storage</h2>
<h3 id="white-box-testing-6">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-6">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-3">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-19">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-004-test-for-sending-sensitvie-data-to-3rd-parties-1"><a name="OMTG-DATAST-004"></a>OMTG-DATAST-004: Test for sending sensitvie data to 3rd Parties</h2>
<h3 id="white-box-testing-7">White-box Testing</h3>
<p>Some 3rd party libraries can be automatically integrated into the App through a wizard within the IDE. The permissions set in the <code>AnroidManifest.xml</code> when installing a library through an IDE wizard should be reviewed. Especially permissions to access <code>SMS (READ_SMS)</code>, contacts (<code>READ_CONTACTS</code>) or the location (<code>ACCESS_FINE_LOCATION</code>) should be challenged if they are really needed to make the library work at a bare minimum, see also OMTG-ENV-XXX. When talking to developers it should be shared to them that it’s actually necessary to have a look at the diff on the project source code before and after the library was installed through the IDE and what changes have been made to the code base.</p>
<p>The same thing applies when adding a library manually. The source code should be checked for API calls or functions provided by the 3rd party library. The applied code changes should be reviewed and it should be checked if available security best practices of the library are applied and used.</p>
<h3 id="black-box-testing-7">Black-box Testing</h3>
<p>All requests made to the external service should be analyzed if any sensitive information is embedded into them.</p>
<ul>
<li>Dynamic analysis can be performed launching a MITM attack using <em>Burp Proxy</em>, to intercept the traffic exchanged between client and server. Using the certificate provided by Portswigger, Burp can intercept and decrypt the traffic on the fly and manipulate it as you prefer. First of all we need to setup Burp, on our laptop, to listen on a specific port from all the interfaces. After that we can setup the Android device to redirect all the traffic to our laptop, i.e. setting our laptop IP address like proxy.<br />
A complete guide can be found <a href="https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp" title="ConfigureAndroidBurp">here</a>. Once we are able to route the traffic to burp, we can try to sniff the traffic from the application. When using the App all requests that are not going directly to the server where the main function is hosted should be checked, if any sensitive information is sent to a 3rd party. This could be for example PII in a tracker or ad service.</li>
<li>When decompiling the App, API calls and/or functions provided through the 3rd party library should be reviewed on a source code level to identify if they are used accordingly to best practices.<br />
The Jar files loaded into the project should be reviewed in order to identify with the developers if they are needed and also if they are out of date and contain known vulnerabilities.</li>
</ul>
<h3 id="remediation-4">Remediation</h3>
<p>All data that is sent to 3rd Party services should be anonymized, so no PII data is available. Also all other data, like IDs in an application that can be mapped to a user account or session should not be sent to a third party.<br />
<code>AndroidManifest.xml</code> should only contain the permissions that are absolutely needed to work properly and as intended.</p>
<h3 id="references-20">References</h3>
<ul>
<li><a href="https://www.amazon.com/Bulletproof-Android-Practical-Building-Developers/dp/0133993329" title="Book_BulletproofAndroid">Bulletproof Android, Godfrey Nolan</a>: Chapter 7 - Third-Party Library Integration</li>
</ul>
<h2 id="omtg-datast-005-test-that-keyboard-cache-is-disabled-for-sensitive-data-1"><a name="OMTG-DATAST-005"></a>OMTG-DATAST-005: Test that keyboard cache is disabled for sensitive data</h2>
<h3 id="white-box-testing-8">White-box Testing</h3>
<p>In the layout definition of an activity TextViews can be defined that have XML attributes. When the XML attribute android:inputType is set with the constant &quot;textNoSuggestions&quot; the keyboard cache is not shown if the input field is selected. Only the keyboard is shown and the user needs to type everytyhing manually and nothing is suggested to him.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">   <span class="kw">&lt;EditText</span>
<span class="ot">        android:id=</span><span class="st">&quot;@+id/KeyBoardCache&quot;</span>
<span class="ot">        android:inputType=</span><span class="st">&quot;textNoSuggestions&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<h3 id="black-box-testing-8">Black-box Testing</h3>
<p>Start the app and click into the input fields that ask for sensitive data. If strings are suggested the keyboard cache is not disabled for this input field.</p>
<h3 id="remediation-5">Remediation</h3>
<p>All input fields that ask for sensitive information, should implement the following XML attribute to disable the keyboard suggestions:</p>
<p>android:inputType=&quot;textNoSuggestions&quot;</p>
<h3 id="references-21">References</h3>
<ul>
<li><a href="https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS" class="uri">https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS</a></li>
</ul>
<h2 id="omtg-datast-006-test-that-clipboard-is-deactivated-for-sensitive-input-fields-1"><a name="OMTG-DATAST-006"></a>OMTG-DATAST-006: Test that clipboard is deactivated for sensitive input fields</h2>
<h3 id="white-box-testing-9">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-9">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-6">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-22">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-007-test-that-no-sensitive-data-is-exposed-via-ipc-mechanisms-1"><a name="OMTG-DATAST-007"></a>OMTG-DATAST-007: Test that no sensitive data is exposed via IPC mechanisms</h2>
<h3 id="white-box-testing-10">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-10">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-7">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-23">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-008-test-that-no-sensitive-data-is-exposed-via-the-user-interface-or-screenshots-1"><a name="OMTG-DATAST-008"></a>OMTG-DATAST-008: Test that no sensitive data is exposed via the user interface or screenshots</h2>
<h3 id="white-box-testing-11">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-11">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-8">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-24">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-009-test-for-sensitive-data-in-backups-1"><a name="OMTG-DATAST-009"></a>OMTG-DATAST-009: Test for Sensitive Data in Backups</h2>
<h3 id="white-box-testing-12">White-box Testing</h3>
<p>In order to backup all your application’s data Android provides an attribute called allowBackup. This attribute is set within the AndroidManifest.xml file. If the value of this attribute is set to true then the device allows user to backup the application using Android Debug Bridge (ADB) - $adb backup. Note: If the device was encrypted then the backup files will be encrypted as well.</p>
<p>Check the AndroidManifest.xml file for the following flag:</p>
<pre><code>android:allowBackup=&quot;true&quot;</code></pre>
<p>If the value is set to true, investigate whether the app saves any kind of sensitive data, either by reading the source code, or inspeciting the files in the app's data directory.</p>
<h3 id="black-box-testing-12">Black-box Testing</h3>
<p>Attempt to make a backup using adb and, if successful, inspect the backup archive for sensitive data. Open a terminal and run the following command:</p>
<pre><code>$ adb backup -apk -nosystem packageNameOfTheDesiredAPK</code></pre>
<p>Approve the backup from your device by selecting the &quot;Back up my data&quot; option. After the backup process is finished, you will have a .ab file in your current working directory.<br />
Run the following command to convert the .ab file into a .tar file.</p>
<pre><code>$ dd if=mybackup.ab bs=24 skip=1|openssl zlib -d &gt; mybackup.tar</code></pre>
<p>Alternatively, use the <a href="https://sourceforge.net/projects/adbextractor/">Android Backup Extractor</a> for this task. To install, download the <a href="https://sourceforge.net/projects/adbextractor/files/latest/download">binary distribution</a>. For the tool to work, you also have to download the <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Oracle JCE Unlimited Strength Jurisdiction Policy Files for JRE7</a> or <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JRE8</a>, and place them in the JRE lib/security folder. Run the following command to convert the tar file:</p>
<pre><code>java -jar android-backup-extractor-20160710-bin/abe.jar unpack backup.ab</code></pre>
<p>Extract the tar file into your current working directory to perform your analysis for sensitive data.</p>
<pre><code>$ tar xvf mybackup.tar</code></pre>
<h3 id="remediation-9">Remediation</h3>
<p>To prevent backing up the app's data, set the android:allowBackup attribute must be set to false in AndroidManifest.xml.</p>
<h3 id="references-25">References</h3>
<ul>
<li>Documentation for the Application tag: <a href="https://developer.android.com/guide/topics/manifest/application-element.html#allowbackup" class="uri">https://developer.android.com/guide/topics/manifest/application-element.html#allowbackup</a></li>
</ul>
<h2 id="omtg-datast-010-test-that-no-sensitive-data-leaks-when-backgrounded-1"><a name="OMTG-DATAST-010"></a>OMTG-DATAST-010: Test that no sensitive data leaks when backgrounded</h2>
<h3 id="white-box-testing-13">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-13">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-10">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-26">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-011-test-for-sensitive-data-disclosure-in-process-memory-1"><a name="OMTG-DATAST-011"></a>OMTG-DATAST-011: Test for Sensitive Data Disclosure in Process Memory</h2>
<h3 id="white-box-testing-14">White-box Testing</h3>
<p>It needs to be identified within the code when sensitive information is stored within a variable and is therefore available within the memory. This information can then be used in dynamic testing when using the App.</p>
<h3 id="black-box-testing-14">Black-box Testing</h3>
<p>To analyse the memory of an app, the app must be debuggable. See the instructions in XXX on how to repackage and sign an Android App to enable debugging for an app, if not already done. Also ADB integration need to be activated in Android Studio in “Tools/Android/Enable ADB Integration” in order to take a memory dump.<br />
For rudimentary analysis Android Studio built in tools can be used. Android studio includes tools in the “Android Monitor” tab to investigate the memory. Select the device and app you want to analyse in the &quot;Android Monitor&quot; tab and click on &quot;Dump Java Heap&quot; and a .hprof file will be created.</p>
<p><img src="http://bb-conservation.de/sven/mem0.png" alt="Create Heap Dump" /></p>
<p>In the new tab that shows the .hprof file, the Package Tree View should be selected. Afterwards the package name of the app can be used to navigate to the instances of classes that were saved in the memory dump.</p>
<p><img src="http://bb-conservation.de/sven/mem1.png" alt="Create Heap Dump" /></p>
<p>For more deeper analysis of the memory dump Eclipse Memory Analyser (MAT) should be used. The .hprof file will be stored in the directory &quot;captures&quot;, relative to the project path open within Android Studio.</p>
<p>Before the hprof file can be opened in MAT the hprof file needs to be converted. The tool hprof-conf can be found in the Android SDK in the directory platform-tools.</p>
<pre><code>./hprof-conv file.hprof file-converted.hprof</code></pre>
<p>By using MAT, more functions are available like usage of the Object Query Language (OQL). OQL is an SQL-like language that can be used to make queries in the memory dump. Analysis should be done on the dominator tree as only this contains the variables/memory of static classes.</p>
<p>When doing a memory analysis check for sensitive information like:</p>
<ul>
<li>Password and/or Username</li>
<li>Decrypted information</li>
<li>User or session related information</li>
<li>Session ID</li>
<li>Interaction with OS, e.g. reading file content</li>
</ul>
<h3 id="remediation-11">Remediation</h3>
<p>If sensitive information is used within the application memory it should be nulled immediately after usage to reduce the attack surface. Information should not be stored in clear text in memory (does this make sense?).</p>
<h3 id="references-27">References</h3>
<ul>
<li>Securely stores sensitive data in RAM - <a href="https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/securely-store-sensitive-data-in-ram/" class="uri">https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/securely-store-sensitive-data-in-ram/</a></li>
</ul>
<p>Tools:</p>
<ul>
<li>Android Studio’s Memory Monitor - <a href="http://developer.android.com/tools/debugging/debugging-memory.html#ViewHeap" class="uri">http://developer.android.com/tools/debugging/debugging-memory.html#ViewHeap</a></li>
<li>Eclipse’s MAT (Memory Analyzer Tool) standalone - <a href="https://eclipse.org/mat/downloads.php" class="uri">https://eclipse.org/mat/downloads.php</a></li>
<li>Memory Analyzer which is part of Eclipse - <a href="https://www.eclipse.org/downloads/" class="uri">https://www.eclipse.org/downloads/</a></li>
<li>Fridump - <a href="http://pentestcorner.com/introduction-to-fridump" class="uri">http://pentestcorner.com/introduction-to-fridump</a></li>
<li>Fridump Repo - <a href="https://github.com/Nightbringer21/fridump" class="uri">https://github.com/Nightbringer21/fridump</a></li>
<li>LiME (formerly DMD) - <a href="https://github.com/504ensicsLabs/LiME" class="uri">https://github.com/504ensicsLabs/LiME</a></li>
</ul>
<h2 id="omtg-datast-012-test-support-of-hardware-backed-keystore-1"><a name="OMTG-DATAST-012"></a>OMTG-DATAST-012: Test support of Hardware-Backed Keystore</h2>
<h3 id="white-box-testing-15">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-15">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-12">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-28">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-013-test-remote-locking-and-wiping-1"><a name="OMTG-DATAST-013"></a>OMTG-DATAST-013: Test remote locking and wiping</h2>
<h3 id="white-box-testing-16">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-16">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-13">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-29">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-014-test-for-device-access-security-policy-1"><a name="OMTG-DATAST-014"></a>OMTG-DATAST-014: Test for device access security policy</h2>
<h3 id="white-box-testing-17">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-17">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-14">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-30">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-015-test-for-usage-of-hardware-based-se-or-tee-1"><a name="OMTG-DATAST-015"></a>OMTG-DATAST-015: Test for usage of hardware-based SE or TEE</h2>
<h3 id="white-box-testing-18">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-18">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-15">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-31">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<!-- References links
If a link is outdated, you can change it here and it will be updated everywhere -->
<!-- OMTG-DATAST-001-1 -->
<!-- OMTG-DATAST-001-2 -->
<!-- OMTG-DATAST-002 -->
<h2 id="omtg-datast-002-testing-for-sensitive-data-disclosure-in-log-files-2"><a name="OMTG-DATAST-002"></a>OMTG-DATAST-002: Testing for Sensitive Data Disclosure in Log Files</h2>
<h3 id="black-box-testing-19">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="white-box-testing-19">White-box Testing</h3>
<p>Check the source code for usage of predefined/custom Logging statements using the following keywords :</p>
<ul>
<li>For predefined and built-in functions :</li>
<li>NSLog</li>
<li>NSAssert</li>
<li>NSCAssert</li>
<li>fprintf</li>
<li>For custom functions :</li>
<li>Logging</li>
<li>Logfile</li>
</ul>
<h3 id="remediation-16">Remediation</h3>
<p>Use a define to enable NSLog statements for development and debugging, and disable these before shipping the software. This can be done by putting the following code into the appropriate PREFIX_HEADER (*.pch) file:</p>
<pre class="c#"><code>#ifdef DEBUG
#   define NSLog (...) NSLog(__VA_ARGS__)
#else
#   define NSLog (...)
#endif</code></pre>
<h3 id="references-32">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-datast-010-test-that-no-sensitive-data-leaks-when-backgrounded-2"><a name="OMTG-DATAST-010"></a>OMTG-DATAST-010: Test that no sensitive data leaks when backgrounded</h2>
<h3 id="black-box-testing-20">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="white-box-testing-20">White-box Testing</h3>
<p>While analyzing the source code, look for the fields or screens where sensitive data is involved. Identify if the application sanitize the screen before being backgrounded.</p>
<h3 id="remediation-17">Remediation</h3>
<p>The application must obsucate/hide any sensitive informations before being backgrouded, either by bluring the screen (e.g. using GPUImageiOSBlurFilter) or overriding the current view in the applicationDidEnterBackground state transition method.</p>
<h3 id="references-33">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h1 id="testing-category">Testing [Category]</h1>
<h2 id="overview-2">Overview</h2>
<p>[Describe what this chapter is about.]</p>
<h2 id="test-cases-1">Test Cases</h2>
<h3 id="omtg-number-namegeneral-description">OMTG-[NUMBER]: [NAME][General description]</h3>
<h4 id="detailed-guides-16">Detailed Guides</h4>
<p>[Add links, e.g.:]</p>
<ul>
<li><a href="LINK#OMTG-DATAST-001">OMTG-DATAST-001 Android</a></li>
<li><a href="0x02_OMTG-DATAST_iOS.md#OMTG-DATAST-001">OMTG-DATAST-001 iOS</a></li>
</ul>
<h4 id="references-34">References</h4>
<ul>
<li>OWASP MASVS: [NUMBER]: &quot;QUOTE&quot;</li>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h2 id="omtg-identifiername"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h2>
<h3 id="white-box-testing-21">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-21">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-18">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-35">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-identifiername-1"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h2>
<h3 id="white-box-testing-22">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-22">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-19">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-36">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h1 id="testing-network-communication">Testing Network Communication</h1>
<h2 id="overview-3">Overview</h2>
<p>[Describe what this chapter is about.]</p>
<h2 id="test-cases-2">Test Cases</h2>
<h3 id="omtg-net-004-testing-ssl-pinning">OMTG-NET-004: Testing SSL Pinning</h3>
<p>Certificate pinning allows to hard-code in the client the certificate that is known to be used by the server. This technique is used to reduce the threat of a rogue CA and CA compromise. Pinning the server’s certificate take the CA out of games. Mobile applications that implements certificate pinning only have to connect to a limited numbers of server, so a small list of trusted CA can be hard-coded in the application.</p>
<h4 id="detailed-guides-17">Detailed Guides</h4>
<ul>
<li><a href="0x04a_OMTG-NET_Android.md#OMTG-NET-004">OMTG-NET-004 Android</a></li>
<li><a href="0x04b_OMTG-NET_iOS.md#OMTG-NET-004">OMTG-NET-004 iOS</a></li>
</ul>
<h4 id="references-37">References</h4>
<ul>
<li>OWASP MASVS : [Link to MASVS]</li>
<li>CWE : [Link to CWE issue]</li>
</ul>
<h2 id="omtg-net-004-testing-ssl-pinning-1"><a name="OMTG-NET-004"></a>OMTG-NET-004: Testing SSL Pinning</h2>
<h3 id="white-box-testing-23">White-box Testing</h3>
<p>The process to implement the SSL pinning involves three main steps outlined below:</p>
<ol>
<li>Obtain a certificate for the desired host</li>
<li>Make sure certificate is in .bks format</li>
<li>Pin the certificate to an instance of the default Apache Httpclient.</li>
</ol>
<p>To analyze the correct implementations of the SSL pinning the HTTP client should:</p>
<ol>
<li>Load the keystore:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">InputStream in = resources.<span class="fu">openRawResource</span>(certificateRawResource);
keyStore = KeyStore.<span class="fu">getInstance</span>(<span class="st">&quot;BKS&quot;</span>);
keyStore.<span class="fu">load</span>(resourceStream, password);</code></pre></div>
<p>Once the keystore is loaded we can use the TrustManager that trusts the CAs in our KeyStore :</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">String tmfAlgorithm = TrustManagerFactory.<span class="fu">getDefaultAlgorithm</span>();
TrustManagerFactory tmf = TrustManagerFactory.<span class="fu">getInstance</span>(tmfAlgorithm);
tmf.<span class="fu">init</span>(keyStore);
Create an SSLContext that uses the TrustManager
<span class="co">// SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);</span>
sslContext.<span class="fu">init</span>(<span class="kw">null</span>, tmf.<span class="fu">getTrustManagers</span>(), <span class="kw">null</span>);</code></pre></div>
<h3 id="black-box-testing-23">Black-box Testing</h3>
<p>Black-box Testing can be performed by launching a MITM attack using your prefered Web Proxy to intercept the traffic exchanged between client (mobile application) and the backend server. If the Proxy is unable to intercept the HTTP requests/responses, the SSL pinning is correctly implemented.</p>
<h3 id="remediation-20">Remediation</h3>
<p>The SSL pinning process should be implemented as described on the static analysis section.</p>
<h3 id="references-38">References</h3>
<ul>
<li>Setting Burp Suite as a proxy for Android Devices : <a href="https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp" class="uri">https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp</a>)</li>
<li>OWASP - Certificate Pinning for Android : <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#Android" class="uri">https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#Android</a></li>
</ul>
<h2 id="omtg-net-004-testing-ssl-pinning-2"><a name="OMTG-NET-004"></a>OMTG-NET-004: Testing SSL Pinning</h2>
<h3 id="white-box-testing-24">White-box Testing</h3>
<p>The code presented below shows how it is possible to check if the certificate provided by the server reflects the certificate hard-coded in the application. The method below implements the connection authentication tells the delegate that the connection will send a request for an authentication challenge.</p>
<p>The delegate must implement connection:canAuthenticateAgainstProtectionSpace: and connection: forAuthenticationChallenge. Within connection: forAuthenticationChallenge, the delegate must call SecTrustEvaluate to perform customary X509 checks. Below a snippet who implements a check of the certificate.</p>
<pre class="objective-c"><code>(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, 0);
NSData *remoteCertificateData = CFBridgingRelease(SecCertificateCopyData(certificate));
NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;MyLocalCertificate&quot; ofType:@&quot;cer&quot;];
NSData *localCertData = [NSData dataWithContentsOfFile:cerPath];
The control below can verify if the certificate received by the server is matching the one pinned in the client.
if ([remoteCertificateData isEqualToData:localCertData]) {
NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
[[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];
}
else {
[[challenge sender] cancelAuthenticationChallenge:challenge];
}</code></pre>
<h3 id="black-box-testing-24">Black-box Testing</h3>
<p>Dynamic analysis can be done by following the same methodology used for the Android applications.</p>
<h3 id="remediation-21">Remediation</h3>
<p>The SSL pinning process should be implemented as described on the static analysis section.</p>
<h3 id="references-39">References</h3>
<ul>
<li>Setting Burp Suite as a proxy for iOS Devices : <a href="https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp" class="uri">https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp</a><br />
References</li>
<li>OWASP - Certificate Pinning for iOS : <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#iOS" class="uri">https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#iOS</a></li>
</ul>
<h1 id="testing-interaction-with-the-environment">Testing Interaction with the Environment</h1>
<h2 id="overview-4">Overview</h2>
<p>[Describe what this chapter is about.]</p>
<h2 id="test-cases-3">Test Cases</h2>
<h3 id="omtg-env-011-testing-the-custom-keyboard">OMTG-ENV-011: Testing the Custom Keyboard</h3>
<p>[Description]</p>
<h4 id="detailed-guides-18">Detailed Guides</h4>
<ul>
<li><a href="0x05a_OMTG-ENV_Android.md#OMTG-ENV-011">OMTG-ENV-011 Android</a></li>
<li><a href="0x05b_OMTG-ENV_iOS.md#OMTG-ENV-011">OMTG-ENV-011 iOS</a></li>
</ul>
<h4 id="references-40">References</h4>
<ul>
<li>OWASP MASVS : [Link to MASVS]</li>
<li>CWE : [Link to CWE issue]</li>
</ul>
<h2 id="omtg-identifiername-2"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h2>
<h3 id="owasp-mobile-top-10-14">OWASP Mobile Top 10</h3>
<p>M[ID] - [Title]</p>
<h3 id="cwe-14">CWE</h3>
<p>CWE [ID] - [Title]</p>
<h3 id="white-box-testing-25">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-25">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-22">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-41">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-identifiername-3"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h2>
<h3 id="owasp-mobile-top-10-15">OWASP Mobile Top 10</h3>
<p>M[ID] - [Title]</p>
<h3 id="cwe-15">CWE</h3>
<p>CWE [ID] - [Title]</p>
<h3 id="white-box-testing-26">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-26">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-23">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-42">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h1 id="testing-code-quality">Testing Code Quality</h1>
<h2 id="overview-5">Overview</h2>
<p>[Describe what this chapter is about.]</p>
<h2 id="test-cases-4">Test Cases</h2>
<h3 id="omtg-code-001-testing-for-debug-build">OMTG-CODE-001: Testing for Debug Build</h3>
<p>Debugging is a technique where a hook is attached to a particular application code. Execution pauses once a particular piece of code is reached (break point), giving us the ability to analyze local variables, dump class values, modify values, and generally interact with the program state. A debug build allows therefore an attacker to attach a debugger to the application in order to analyze the behavior during runtime.</p>
<h4 id="detailed-guides-19">Detailed Guides</h4>
<p>[Add links, e.g.:]</p>
<ul>
<li><a href="LINK#OMTG-CODE-001">OMTG-CODE-001 Android</a></li>
<li><a href="0x02_OMTG-CODE_iOS.md#OMTG-CODE-001">OMTG-CODE-001 iOS</a></li>
</ul>
<h4 id="references-43">References</h4>
<ul>
<li>OWASP MASVS: [NUMBER]: &quot;QUOTE&quot;</li>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-code-002-testing-for-exception-handling">OMTG-CODE-002: Testing for Exception Handling</h3>
<p>[General description]</p>
<h4 id="detailed-guides-20">Detailed Guides</h4>
<p>[Add links, e.g.:]</p>
<ul>
<li><a href="LINK#OMTG-CODE-002">OMTG-CODE-002 Android</a></li>
<li><a href="0x02_OMTG-CODE_iOS.md#OMTG-CODE-002">OMTG-CODE-002 iOS</a></li>
</ul>
<h4 id="references-44">References</h4>
<ul>
<li>OWASP MASVS: [NUMBER]: &quot;QUOTE&quot;</li>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-code-003-testing-for-secure-compiler-flags">OMTG-CODE-003: Testing for Secure Compiler Flags</h3>
<p>Compilers such as CLANG and GCC support hardening options that add additional runtime security features and checks to the generated executables. While these hardening features don’t fix broken code, they do make exploitation of bugs such as buffer overflows more difficult, and should be activated as a defense-in-depth measure.</p>
<p>This test-case aim to check whether the following Flags are enabled whitin the mobile application's binary :</p>
<ul>
<li>Stack smashing protection :<br />
Stack smashing is the willful use of stack overflows to gain control of a system. There are different buffer overflow protectors available, include Stack Smashing Protector (SSP) for GNU's gcc, ProPolice for IBM's XLC, and Buffer Security Check for Microsoft's Visual compilers (option /GS).</li>
<li>PIE support :<br />
Position-independent executables (PIE) are binaries that can be wholly relocated in memory. Building an app with PIE support makes it possible to apply Address Space Layout Randomization (ASLR) during runtime. ASLR aims to make exploitation of memory corruption vulnerabilities more difficult. As of Android 5.0, Android requires all dynamically linked executables to support PIE.</li>
<li>ARC protection :<br />
Automatic Reference Counting (ACR) is a compile time protection technique introduced since iOS 5. It provide an additional layer of security at runtime by moving the responsibility of memory management (retains, releases, and autoreleases on Objective-C objects ) from the programmer to the compiler.</li>
</ul>
<h4 id="detailed-guides-21">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-CODE_Android.md#OMTG-CODE-003">OMTG-CODE-003 Android</a></li>
<li><a href="0x06b_OMTG-CODE_iOS.md#OMTG-CODE-003">OMTG-CODE-003 iOS</a></li>
</ul>
<h4 id="references-45">References</h4>
<ul>
<li>OWASP MASVS : [Link to MASVS]</li>
<li>CWE : [Link to CWE issue]</li>
</ul>
<h2 id="omtg-code-001-testing-for-debug-build-1"><a name="OMTG-CODE-001"></a>OMTG-CODE-001: Testing for Debug Build</h2>
<h3 id="white-box-testing-27">White-box Testing</h3>
<p>Check the AndroidManifest.xml for the value of &quot;android:debuggable&quot; attribute within the application element :</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;manifest</span><span class="ot"> xmlns:android=</span><span class="st">&quot;http://schemas.android.com/apk/res/android&quot;</span><span class="ot"> package=</span><span class="st">&quot;com.android.owasp&quot;</span><span class="kw">&gt;</span>
    
    ...
    
    <span class="kw">&lt;application</span><span class="ot"> android:allowBackup=</span><span class="st">&quot;true&quot;</span><span class="ot"> android:debuggable=</span><span class="st">&quot;true&quot;</span><span class="ot"> android:icon=</span><span class="st">&quot;@drawable/ic_launcher&quot;</span><span class="ot"> android:label=</span><span class="st">&quot;@string/app_name&quot;</span><span class="ot"> android:theme=</span><span class="st">&quot;@style/AppTheme&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;meta-data</span><span class="ot"> android:name=</span><span class="st">&quot;com.owasp.main&quot;</span><span class="ot"> android:value=</span><span class="st">&quot;.Hook&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;/application&gt;</span>
<span class="kw">&lt;/manifest&gt;</span></code></pre></div>
<p>This setting specifies whether or not the application can be debugged, even when running on a device in user mode. A value of &quot;true&quot; if it can be, And &quot;false&quot; if not. The default value is &quot;false&quot;.</p>
<p>A comprehensive guide to debug an Android application can be found within the official documentation by Android (see references).</p>
<h3 id="black-box-testing-27">Black-box Testing</h3>
<p>When targetting a compiled Android application, the most reliable method is to first decompile it in order to obtain the AndroidManifest.xml file (see Decompiling Android App Guide - #TODO-Create a general guide that can bee referenced anywhere in the OMSTF) and check the value of &quot;android:debuggable&quot; attribute.</p>
<p>Otherwise, use the Android Asset Packaging Tool (aapt) to check the debuggable flag :</p>
<pre><code>$ aapt l -a /path/to/apk/file.apk | grep debuggable</code></pre>
<p>Will return the following if android:debuggable parameter is set to true :</p>
<pre><code>      A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</code></pre>
<h3 id="remediation-24">Remediation</h3>
<p>For production releases, the attribute android:debuggable must be set to false within the application element. This ensures that a debugger cannot attach to the process of the application.</p>
<h3 id="references-46">References</h3>
<ul>
<li>Configuring your application for release - <a href="http://developer.android.com/tools/publishing/preparing.html#publishing-configure" class="uri">http://developer.android.com/tools/publishing/preparing.html#publishing-configure</a></li>
<li>Debugging with Android Studio - <a href="http://developer.android.com/tools/debugging/debugging-studio.html" class="uri">http://developer.android.com/tools/debugging/debugging-studio.html</a></li>
</ul>
<h2 id="omtg-code-003-testing-for-secure-compiler-flags-1"><a name="OMTG-CODE-003"></a>OMTG-CODE-003: Testing for Secure Compiler Flags</h2>
<p>Since most Android applications are Java based, they are <a href="https://www.owasp.org/index.php/Reviewing_Code_for_Buffer_Overruns_and_Overflows#.NET_.26_Java">immunue</a> to buffer overflow vulnerabilities.</p>
<h2 id="omtg-code-001-testing-for-secure-compiler-flags"><a name="OMTG-CODE-007"></a>OMTG-CODE-001: Testing for Secure Compiler Flags</h2>
<h3 id="white-box-testing-28">White-box Testing</h3>
<h4 id="with-otool">With otool :</h4>
<ul>
<li>Check if the stack smashing protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep stack</code></pre>
<p>If the application was compiled with the stack smashing protection two undefined symbols will be present: &quot;_<strong>stack_chk_fail&quot; and &quot;</strong>_stack_chk_guard&quot;.</p>
<ul>
<li>Check the PIE protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep PIE</code></pre>
<p>If the above command emit no output then the PIE protection isn't enabled.</p>
<ul>
<li>Check the ACR protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep _objc_release</code></pre>
<p>If the above command emit no output then the ACR protection isn't enabled.</p>
<h4 id="with-idb">With idb :</h4>
<p>IDB automates the process of checking for both stack canary and PIE support. Select the target binary in the IDB gui and click the &quot;Analyze Binary…&quot; button.</p>
<p><img src="https://github.com/OWASP/owasp-mstg/blob/master/Document/images/idb.png" alt="alt tag" /></p>
<h3 id="black-box-testing-28">Black-box Testing</h3>
<p>This test case should be performed during White-box testing.</p>
<h3 id="remediation-25">Remediation</h3>
<ul>
<li>Stack smashing protection</li>
</ul>
<p>Steps for enabling Stack smashing protection within an iOS application :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>Verify that &quot;–fstack-protector-all&quot; option is selected under &quot;Other C Flags&quot; section.</li>
</ol>
<ul>
<li>PIE support</li>
</ul>
<p>Steps for building an iOS application as PIE :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>For iOS apps, set iOS Deployment Target to iOS 4.3 or later. For Mac apps, set OS X Deployment Target to OS X 10.7 or later.</li>
<li>Verify that &quot;Generate Position-Dependent Code&quot; is set at its default value of NO.</li>
<li>Verify that Don't &quot;Create Position Independent Executables&quot; is set at its default value of NO.</li>
</ol>
<ul>
<li>ARC protection</li>
</ul>
<p>Steps for enabling ACR protection within an iOS application :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>Verify that &quot;Objective-C Automatic Reference Counting&quot; is set at its default value of YES.</li>
</ol>
<h3 id="references-47">References</h3>
<ul>
<li>Technical Q&amp;A QA1788 Building a Position Independent Executable : <a href="https://developer.apple.com/library/mac/qa/qa1788/_index.html" class="uri">https://developer.apple.com/library/mac/qa/qa1788/_index.html</a></li>
<li>idb : <a href="https://github.com/dmayer/idb" class="uri">https://github.com/dmayer/idb</a></li>
</ul>
<h1 id="testing-resiliency-against-reverse-engineering">Testing Resiliency Against Reverse Engineering</h1>
<h2 id="overview-6">Overview</h2>
<p>This chapter covers defense-in-depth measures that are recommended for apps that process, or give access to, sensitive data or functionality. Lack of any of these controls does not cause a vulnerability - instead, they are meant to increase the app's resiliency against reverse engineering, making it more difficult for adversaries to gain an understanding of the app's internals or extract data from the app.</p>
<h2 id="test-cases-5">Test Cases</h2>
<h3 id="omtg-rare-001-test-for-debugging-symbols-in-binaries">OMTG-RARE-001: Test for Debugging Symbols in Binaries</h3>
<p>As a general rule of thumb, as little explanative information as possible should be provided along with the compiled code. Some metadata such as debugging information, line numbers and descriptive function or method names make the binary or bytecode easier to understand for the reverse engineer, but isn’t actually needed in a release build and can therefore be safely discarded without impacting the functionality of the app.<br />
By default, both ELF and Mach-O binaries have a symbol table that contains debugging information, including the names of functions, global variables and types used in the executable. This information is used to resolve references when linking dynamic libraries, and also makes it easier to keep track of the semantics of the code and debugging crashes. It can however be stripped from the release build, unless the goal is to release a dynamic library for public use.</p>
<h4 id="detailed-guides-22">Detailed Guides</h4>
<ul>
<li><a href="0x07a_OMTG-RARE_Android.md#OMTG-RARE-001">OMTG-DATAST-001 Android</a></li>
<li><a href="0x07b_OMTG-RARE_iOS.md#OMTG-DATAST-001">OMTG-DATAST-001 iOS</a></li>
</ul>
<h4 id="references-48">References</h4>
<ul>
<li>OWASP MASVS: V8-1: &quot;Verify that debugging symbols have been removed from native binaries.&quot;</li>
<li>CWE: N/A</li>
</ul>
<h3 id="omtg-rare-002-test-for-meaningful-identifiers-in-java-bytecode">OMTG-RARE-002: Test for Meaningful Identifiers in Java Bytecode</h3>
<p>[General description]</p>
<h4 id="detailed-guides-23">Detailed Guides</h4>
<ul>
<li><a href="0x07a_OMTG-RARE_Android.md#OMTG-RARE-002">OMTG-RARE-002 Android</a></li>
<li><a href="0x07b_OMTG-RARE_iOS.md#OMTG-RARE-002">OMTG-RARE-002 iOS</a></li>
</ul>
<h4 id="references-49">References</h4>
<ul>
<li>OWASP MASVS: V8-2: &quot;Verify that Java bytecode has been obscured through identifier renaming.&quot;</li>
<li>CWE: N/A</li>
</ul>
<h3 id="omtg-rare-003-test-jailbreak-root-detection">OMTG-RARE-003: Test Jailbreak / Root Detection</h3>
<p>Modern smartphone operating systems implement containerization so that each app is restricted to its own sandbox. A regular app cannot access files outside its dedicated data directories, and access to system APIs is restricted via app privileges. As a result, an app’s sensitive data as well as the integrity of the OS is guaranteed under normal conditions. However, when an adversary gains root access to the mobile operating system, the default protections can be bypassed completely.</p>
<p>The risk of malicious code running as root is higher on rooted or jailbroken devices, as some of the default integrity checks are disabled. Developers of apps that handle highly sensitive data (e.g. banking) should therefore consider implementing checks that prevent the app from running under these conditions.</p>
<h4 id="detailed-guides-24">Detailed Guides</h4>
<ul>
<li><a href="0x07a_OMTG-RARE_Android.md#OMTG-RARE-003">OMTG-RARE-003 Android</a></li>
<li><a href="0x07b_OMTG-RARE_iOS.md#OMTG-RARE-003">OMTG-RARE-003 iOS</a></li>
</ul>
<h4 id="references-50">References</h4>
<ul>
<li>OWASP MASVS : V8.3: &quot;Verify that the application detects whether it is being executed on a rooted or jailbroken device. Depending on the business requirement, users should be warned, or the app should terminate if the device is rooted.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-004-test-verification-of-installation-source">OMTG-RARE-004: Test Verification of Installation Source</h3>
<p>(todo)</p>
<h4 id="detailed-guides-25">Detailed Guides</h4>
<ul>
<li><a href="0x07a_OMTG-RARE_Android.md#OMTG-RARE-004">OMTG-RARE-004 Android</a></li>
<li><a href="0x07b_OMTG-RARE_iOS.md#OMTG-RARE-004">OMTG-RARE-004 iOS</a></li>
</ul>
<h4 id="references-51">References</h4>
<ul>
<li>OWASP MASVS : V8.4: &quot;Verify that the app checks its installation source, and only runs if installed from a trusted source.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-005-test-simple-debugger-detection-prevention">OMTG-RARE-005: Test Simple Debugger Detection / Prevention</h3>
<p>(todo)</p>
<h4 id="detailed-guides-26">Detailed Guides</h4>
<ul>
<li><a href="0x07a_OMTG-RARE_Android.md#OMTG-RARE-005">OMTG-RARE-005 Android</a></li>
<li><a href="0x07b_OMTG-RARE_iOS.md#OMTG-RARE-005">OMTG-RARE-005 iOS</a></li>
</ul>
<h4 id="references-52">References</h4>
<ul>
<li>OWASP MASVS : V8.5: &quot;Verify that the app has some form of debugger detection and terminates when a debugger is detected, or prevents attaching a debugger using any method. All available means of debugging must be covered (e.g. JDWP and native).&quot;</li>
<li>CWE : N/A</li>
</ul>
<h2 id="omtg-rare-001-test-for-debugging-symbols-in-binaries-1"><a name="OMTG-RARE-001"></a>OMTG-RARE-001: Test for Debugging Symbols in Binaries</h2>
<h3 id="white-box-testing-29">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-29">Black-box Testing</h3>
<p>Symbols are usually stripped during the build process, so you need the compiled bytecode and libraries to verify whether the any unnecessary metadata has been discarded. For native binaries, use a standard tool like nm or objdump to inspect the symbol table. For example:</p>
<pre><code>berndt@osboxes:~/ $ objdump -t my_library.so
my_library.so:     file format elf32-little

SYMBOL TABLE:
no symbols</code></pre>
<p>Alternatively, open the file in your favorite disassembler and look for debugging symbols. For native libraries, it should be checked that the names of exports don’t give away the location of sensitive functions.</p>
<h3 id="remediation-26">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-53">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-002-test-for-meaningful-identifiers-in-java-bytecode-1"><a name="OMTG-RARE-002"></a>OMTG-RARE-002: Test for Meaningful Identifiers in Java Bytecode</h2>
<h3 id="white-box-testing-30">White-box Testing</h3>
<p>Verify the minifyEnabled is set to true in build.gradle (see below).</p>
<h3 id="black-box-testing-30">Black-box Testing</h3>
<p>To inspect the Java bytecode for metadata either use the dexdump tool that ships with the Android SDK or a decompiler.</p>
<p><img src="../images/proguard.jpg" alt="ProGuard-obfuscated code" /></p>
<h3 id="remediation-27">Remediation</h3>
<p>ProGuard should be used to strip unneeded debugging information from the Java bytecode. By default, ProGuard removes attributes that are useful for debugging, including line numbers, source file names and variable names. ProGuard is a free Java class file shrinker, optimizer, obfuscator, and preverifier. It is shipped with Android’s SDK tools. To activate shrinking for the release build, add the following to build.gradle:</p>
<pre><code>android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(‘proguard-android.txt&#39;),
                    &#39;proguard-rules.pro&#39;
        }
    }
    ...
}</code></pre>
<h3 id="references-54">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-003-test-jailbreak-root-detection-1"><a name="OMTG-RARE-003"></a>OMTG-RARE-003: Test Jailbreak / Root Detection</h2>
<h3 id="white-box-testing-31">White-box Testing</h3>
<p>Root detection is usually implemented as a number of environmental checks, such as checking for files and processes known to be found only on rooted devices, or artefacts of widely used rooting tools. If you have access to the source code, make sure that there is at least a check for the presence of the &quot;su&quot; binary in common locations, including:</p>
<pre><code>/system/bin/su
/system/xbin/su
/sbin/su</code></pre>
<p>It is also possible to check for app packages of typical rooting tools, such as Superuser.apk. However, the presence and location of these files varies heavily depending on the specific Android and tool version.</p>
<p>Another option is checking the list of installed apps against a package names of known rooting tools, such as:</p>
<pre><code>eu.chainfire.supersu
com.koushikdutta.superuser</code></pre>
<p>The package list can be obtained via the PackageManager:</p>
<pre><code>final PackageManager pm = getPackageManager();

List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);</code></pre>
<h3 id="black-box-testing-31">Black-box Testing</h3>
<p>Install the app on a rooted device and launch the app. If the app functions without any issues, then this test fails.</p>
<h3 id="references-55">References</h3>
<ul>
<li>Netspi Blog - <a href="https://blog.netspi.com/android-root-detection-techniques/" class="uri">https://blog.netspi.com/android-root-detection-techniques/</a></li>
<li>InfoSec Institute - <a href="http://resources.infosecinstitute.com/android-hacking-security-part-8-root-detection-evasion/" class="uri">http://resources.infosecinstitute.com/android-hacking-security-part-8-root-detection-evasion/</a></li>
</ul>
<h2 id="omtg-rare-004-test-verification-of-installation-source-1"><a name="OMTG-RARE-004"></a>OMTG-RARE-004: Test Verification of Installation Source</h2>
<h3 id="white-box-testing-32">White-box Testing</h3>
<h3 id="black-box-testing-32">Black-box Testing</h3>
<h3 id="references-56">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-005-test-simple-debugger-detection-prevention-1"><a name="OMTG-RARE-005"></a>OMTG-RARE-005: Test Simple Debugger Detection / Prevention</h2>
<h3 id="white-box-testing-33">White-box Testing</h3>
<h3 id="black-box-testing-33">Black-box Testing</h3>
<h3 id="references-57">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-001-test-for-debugging-symbols-in-binaries-2"><a name="OMTG-RARE-001"></a>OMTG-RARE-001: Test for Debugging Symbols in Binaries</h2>
<h3 id="white-box-testing-34">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-34">Black-box Testing</h3>
<p>Symbols are usually stripped during the build process, so you need the compiled bytecode and libraries to verify whether the any unnecessary metadata has been discarded. For native binaries, use a standard tool like nm or objdump to inspect the symbol table. For example:</p>
<pre><code>berndt@osboxes:~/ $ objdumpApplication Security Verification Standard -t my_library.so
my_library.so:     file format elf32-little

SYMBOL TABLE:
no symbols</code></pre>
<p>Alternatively, open the file in your favorite disassembler and look for debugging symbols. For native libraries, it should be checked that the names of exports don’t give away the location of sensitive functions.</p>
<h3 id="remediation-28">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-58">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-002-test-for-meaningful-identifiers-in-java-bytecode-2"><a name="OMTG-RARE-002"></a>OMTG-RARE-002: Test for Meaningful Identifiers in Java Bytecode</h2>
<p>This test case is not applicable on iOS.</p>
<h2 id="omtg-rare-003-test-jailbreak-root-detection-2"><a name="OMTG-RARE-003"></a>OMTG-RARE-003: Test Jailbreak / Root Detection</h2>
<h3 id="white-box-testing-35">White-box Testing</h3>
<h3 id="black-box-testing-35">Black-box Testing</h3>
<h3 id="references-59">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-004-test-verification-of-installation-source-2"><a name="OMTG-RARE-004"></a>OMTG-RARE-004: Test Verification of Installation Source</h2>
<h3 id="white-box-testing-36">White-box Testing</h3>
<h3 id="black-box-testing-36">Black-box Testing</h3>
<h3 id="references-60">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-rare-005-test-simple-debugger-detection-prevention-2"><a name="OMTG-RARE-005"></a>OMTG-RARE-005: Test Simple Debugger Detection / Prevention</h2>
<h3 id="white-box-testing-37">White-box Testing</h3>
<h3 id="black-box-testing-37">Black-box Testing</h3>
<h3 id="references-61">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
