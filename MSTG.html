<h1 id="section"></h1>
<p><img src="images/OWASP_logo.png" alt="OWASP LOGO" /></p>
<h1 id="mobile-application-security-testing-guide">Mobile Application Security Testing Guide</h1>
<p>[date]</p>
<h1 id="foreword">Foreword</h1>
<h1 id="frontispiece">Frontispiece</h1>
<h2 id="about-the-owasp-mobile-security-testing-guide">About the OWASP Mobile Security Testing Guide</h2>
<p>The OWASP Mobile Security Testing Guide (MSTG) is a comprehensive manual for testing the security of mobile apps. It describes technical processes for verifying the controls listed in the OWASP Mobile Application Verification Standard (MASVS). The MSTG is meant to provide a baseline set of test cases for black-box and white-box security tests, and to help ensure completeness and consistency of the tests.</p>
<p>OWASP thanks the many authors, reviewers, and editors for their hard work in developing this guide. If you have any comments or suggestions on the Mobile Testing Guide, please join the discuss the MASVS or MSTG join the <a href="https://owasp.slack.com/messages/project-mobile_omtg/details/">OWASP Mobile Security Project Slack Channel</a>. You can sign up here:</p>
<p><a href="http://owasp.herokuapp.com/" class="uri">http://owasp.herokuapp.com/</a></p>
<h2 id="copyright-and-license">Copyright and License</h2>
<p><img src="images/license.png" alt="license" /><br />
Copyright © 2016 The OWASP Foundation. This document is released under the Creative Commons Attribution ShareAlike 3.0 license. For any reuse or distribution, you must make clear to others the license terms of this work.</p>
<table>
<thead>
<tr class="header">
<th>Project Leads</th>
<th>Lead Authors</th>
<th>Contributors and Reviewers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bernhard Mueller, Sven Schleier</td>
<td>Sebastian Banescu, Stephen Corbiaux, Bernhard Mueller, Sven Schleier, Francesco Stillavato, Abdessamad Temmar, Stephanie Vanroelen, Gerhard Wagner, Jeroen Willemsen</td>
<td>Cláudio André, Davide Cioccia, Bao Le, Shiv Patel, Prathan Phongthiproek, Abhinav Sejpal, Anant Shrivastava, Milan Singh Thakur, Pragati Singh, Blessen Thomas, Dennis Titze, Bernard Wagner</td>
</tr>
</tbody>
</table>
<h2 id="revision-history">Revision History</h2>
<p>The Mobile Security Testing Guide was initiated by Milan Singh Thakur in 2015. The original document was hosted on Google Drive. Guide development was moved to GitHub in October 2016.</p>
<h3 id="owasp-mstg-beta-2-google-doc">OWASP MSTG Beta 2 (Google Doc)</h3>
<table>
<thead>
<tr class="header">
<th>Authors</th>
<th>Reviewers</th>
<th>Top Contributors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Milan Singh Thakur, Abhinav Sejpal, Pragati Singh, Mohammad Hamed Dadpour, David Fern, Mirza Ali, Rahil Parikh, Anant Shrivastava, Stephen Corbiaux, Ryan Dewhurst, Anto Joseph, Bao Lee, Nutan Kumar Panda, Julian Schütte, Stephanie Vanroelen, Gerhard Wagner</td>
<td>Andrew Muller, Jonathan Carter, Stephanie Vanroelen, Milan Singh Thakur</td>
<td>Jim Manico, Paco Hope, Pragati Singh, Yair Amit, Amin Lalji, OWASP Mobile Team</td>
</tr>
</tbody>
</table>
<h3 id="owasp-mstg-beta-1-google-doc">OWASP MSTG Beta 1 (Google Doc)</h3>
<table>
<thead>
<tr class="header">
<th>Authors</th>
<th>Reviewers</th>
<th>Top Contributors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Milan Singh Thakur, Abhinav Sejpal, Pragati Singh, Mohammad Hamed Dadpour, David Fern, Mirza Ali, Rahil Parikh</td>
<td>Andrew Muller, Jonathan Carter</td>
<td>Jim Manico, Paco Hope, Yair Amit, Amin Lalji, OWASP Mobile Team</td>
</tr>
</tbody>
</table>
<h1 id="the-owasp-mobile-security-project">The OWASP Mobile Security Project</h1>
<h1 id="mobile-platforms-overview">Mobile Platforms Overview</h1>
<p>This section briefly describes the security mechanisms and underlying guarantees of Android and iOS.</p>
<p>(... TODO ...)</p>
<h2 id="mobile-applications-overview">Mobile Applications Overview</h2>
<p>Mobile development has taken world to a ride and we have many different ways of developing applications for all mobile platforms.</p>
<ul>
<li>Native Apps:</li>
<li><strong>Android</strong>: Applications are primarily written in Java by using the Android SDK. However code logic could be abstracted out as a C binary by using the Android NDK to provide low-level functionality and speed.</li>
<li><strong>iOS</strong>: Primarily written in Objective C by using Xcode IDE. With introduction of Swift slowly the primary language is shifting to Swift.</li>
<li>HTML5 Apps: The base for HTML5 Apps are JavaScript, CSS and HTML5 technologies. They are web sites but display effectively on mobile devices.</li>
<li>Hybrid Apps: Hybrid applications are basically web applications that are rendered in the native browser of the mobile operating system, for example UIWebView in iOS or WebView in Android. The base for Hybrid-Apps are JavaScript, CSS and HTML that are packaged in a native application.</li>
</ul>
<p>There are various frameworks which allow you to write software in one language and compile the application for multiple platforms. Examples for such frameworks are:</p>
<ul>
<li><a href="http://phonegap.com/">Phonegap</a></li>
<li><a href="https://cordova.apache.org/">Cordova</a></li>
<li><a href="http://www.kony.com/">Kony</a></li>
<li><a href="https://www.b4x.com/">B4X</a></li>
</ul>
<h2 id="android">Android</h2>
<p>(... TODO ...)</p>
<p>Android is an open source platform that can be found nowadays on many devices:</p>
<ul>
<li>Mobile Phones and Tablets</li>
<li>Wearables</li>
<li>&quot;Smart&quot; devices in general like TVs</li>
</ul>
<p>It also offers an application environment that supports not only pre-installed applications on the device, but also 3rd party applications that can be downloaded from marketplaces like Google Play.</p>
<p>The software stack of Android comprises of different layers, where each layer is defining certain behavior and offering specific services to the layer above.</p>
<p><img src="https://source.android.com/security/images/android_software_stack.png" alt="Android Software Stack" /></p>
<p>On the lowest level Android is using the Linux Kernel where the core operating system is built up on. The hardware abstraction layer defines a standard interface for hardware vendors. HAL implementations are packaged into shared library modules (.so files). These modules will be loaded by the Android system at the appropriate time. The Android Runtime consists of the core libraries and the Dalvik VM (Virtual Machine). Applications are most often implemented in Java and compiled in Java class files and then compiled again into the dex format. The dex files are then executed within the Dalvik VM. With Android 4.4 the successor of Dalvik VM was introduced, called Android Runtime (ART). Applications are executed in the Android Application Sandbox that enforces isolation of application data and code execution from other applications on the device, that adds an additional layer of security.</p>
<p>The Android Framework is creating an abstraction layer for all the layers below, so developers can implement Android Apps and can utilize the capabilities of Android without deeper knowledge of the layers below. It also offers a robust implementation that offers common security functions like secure IPC or cryptography.</p>
<p>(... TODO ...)</p>
<h3 id="inter-process-communication">Inter-Process Communication</h3>
<p>As we know, every process on Android has its own sandboxed address space. Inter-process communication (IPC) facilities enable apps to exchange signals and data in a (hopefully) secure way. Instead of relying on the default Linux IPC facilities, IPC on Android is done through Binder, a custom implementation of OpenBinder. A lot of Android system services, as well as all high-level IPC services, depend on Binder.</p>
<p>In the Binder framework, a client-server communication model is used. IPC clients communicate through a client-side proxy. This proxy connects to the Binder server, which is implemented as a character driver (/dev/binder).The server holds a thread pool for handling incoming requests, and is responsible for delivering messages to the destination object. Developers write interfaces for remote services using the Android Interface Descriptor Language (AIDL).</p>
<p><img src="/Document/images/binder.jpg" alt="Binder Overview" /><br />
<em>Binder Overview. Image source: <a href="https://www.nds.rub.de/media/attachments/files/2011/10/main.pdf">Android Binder by Thorsten Schreiber</a></em></p>
<h4 id="high-level-abstractions">High-Level Abstractions</h4>
<p><em>Intent messaging</em> is a framework for asynchronous communication built on top of binder. This framework enables both point-to-point and publish-subscribe messaging. An <em>Intent</em> is a messaging object that can be used to request an action from another app component. Although intents facilitate communication between components in several ways, there are three fundamental use cases:</p>
<ul>
<li><p>Explicit intents specify the component to start by name (the fully-qualified class name).</p></li>
<li><p>Implicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. When you create an implicit intent, the Android system finds the appropriate component to start by comparing the contents of the intent to the intent filters declared in the manifest file of other apps on the device.</p></li>
</ul>
<p>An <em>intent filter</em> is an expression in an app's manifest file that specifies the type of intents that the component would like to receive. For instance, by declaring an intent filter for an activity, you make it possible for other apps to directly start your activity with a certain kind of intent. Likewise, if you do not declare any intent filters for an activity, then it can be started only with an explicit intent.</p>
<p>For activities and broadcast receivers, intents are the preferred mechanism for asynchronous IPC in Android. Depending on your application requirements, you might use sendBroadcast(), sendOrderedBroadcast(), or an explicit intent to a specific application component.</p>
<p>A BroadcastReceiver handles asynchronous requests initiated by an Intent.</p>
<p>Using Binder or Messenger is the preferred mechanism for RPC-style IPC in Android. They provide a well-defined interface that enables mutual authentication of the endpoints, if required.</p>
<p>(... TODO ... briefly on security implications)</p>
<p>Android’s Messenger represents a reference to a Handler that can be sent to a remote process via an Intent</p>
<p>A reference to the Messenger can be sent via an Intent using the previously mentioned IPC mechanism</p>
<p>Messages sent by the remote process via the messenger are delivered to the local handler. Great for efficient call-backs from the service to the client</p>
<h4 id="security-implications">Security Implications</h4>
<h3 id="android-application-overview">Android Application Overview</h3>
<h4 id="app-folder-structure">App Folder Structure</h4>
<p>Android applications installed (from Google Play Store or from external sources) are located at /data/app/. Since this folder cannot be listed without root, another way has to be used to get the exact name of the apk. To list all installed apks, the Android Debug Bridge (adb) can be used. ADB allows a tester to directly interact with the real phone, e.g., to gain access to a console on the device to issue further commands, list installed packages, start/stop processes, etc.<br />
To do so, the device has to have USB-Debugging enabled (under developer settings) and has to be connected via USB.<br />
Once USB-Debugging is enabled, the connected devices can be viewed with the command</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">adb</span> devices
<span class="kw">List</span> of devices attached
<span class="kw">BAZ5ORFARKOZYDFA</span>    device</code></pre></div>
<p>Then the following command lists all installed apps and their locations:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">adb</span> shell pm list packages -f
<span class="kw">package</span>:/system/priv-app/MiuiGallery/MiuiGallery.apk=com.miui.gallery
<span class="kw">package</span>:/system/priv-app/Calendar/Calendar.apk=com.android.calendar
<span class="kw">package</span>:/system/priv-app/BackupRestoreConfirmation/BackupRestoreConfirmation.apk=com.android.backupconfirm</code></pre></div>
<p>To pull one of those apps from the phone, the following command can be used:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">adb</span> pull /data/app/com.google.android.youtube-1/base.apk</code></pre></div>
<p>This file only contains the “installer” of the application, meaning this is the app the developer uploaded to the market.<br />
The local data of the application is stored at /data/data/PACKAGE-NAME and has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">drwxrwx--x</span> u0_a65   u0_a65            2016-01-06 03:26 cache
<span class="kw">drwx------</span> u0_a65   u0_a65            2016-01-06 03:26 code_cache
<span class="kw">drwxrwx--x</span> u0_a65   u0_a65            2016-01-06 03:31 databases
<span class="kw">drwxrwx--x</span> u0_a65   u0_a65            2016-01-10 09:44 files
<span class="kw">drwxr-xr-x</span> system   system            2016-01-06 03:26 lib
<span class="kw">drwxrwx--x</span> u0_a65   u0_a65            2016-01-10 09:44 shared_prefs</code></pre></div>
<ul>
<li><strong>cache</strong>: This location used to cache application data on runtime including WebView caches.</li>
<li><strong>code_cache</strong>: TBD</li>
<li><strong>databases</strong>: This folder stores sqlite database files generated by the application at runtime, e.g. to store user data</li>
<li><strong>files</strong>: This folder is used to store files that are created in the App when using the internal storage.</li>
<li><strong>lib</strong>: This folder used to store native libraries written in C/C++. These libraries can have file extension as .so, .dll (x86 support). The folder contains subfolders for the platforms the app has native libraries for:</li>
<li>armeabi: compiled code for all ARM based processors only</li>
<li>armeabi-v7a: compiled code for all ARMv7 and above based processors only</li>
<li>arm64-v8a: compiled code for all ARMv8 arm64 and above based processors only</li>
<li>x86: compiled code for x86 processors only</li>
<li>x86_64: compiled code for x86_64 processors only</li>
<li>mips: compiled code for MIPS processors only</li>
<li><strong>shared_prefs</strong>: This folder is used to store the preference file generated by application on runtime to save current state of application including data, configuration, session, etc. The file format is XML.</li>
</ul>
<h4 id="apk-structure">APK Structure</h4>
<p>An application on Android is a file with the extension .apk. This file is a signed zip-file which contains different files for the bytecode, assets, etc. When unzipped the following directory structure can be identified:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">unzip</span> base.apk
$ <span class="kw">ls</span> -lah
<span class="kw">-rw-r--r--</span>   1 sven  staff    11K Dec  5 14:45 AndroidManifest.xml
<span class="kw">drwxr-xr-x</span>   5 sven  staff   170B Dec  5 16:18 META-INF
<span class="kw">drwxr-xr-x</span>   6 sven  staff   204B Dec  5 16:17 assets
<span class="kw">-rw-r--r--</span>   1 sven  staff   3.5M Dec  5 14:41 classes.dex
<span class="kw">drwxr-xr-x</span>   3 sven  staff   102B Dec  5 16:18 lib
<span class="kw">drwxr-xr-x</span>  27 sven  staff   918B Dec  5 16:17 res
<span class="kw">-rw-r--r--</span>   1 sven  staff   241K Dec  5 14:45 resources.arsc</code></pre></div>
<ul>
<li><strong>AndroidManifest.xml</strong>: Contains the definition of application’s package name, target and min API version, application configuration, application components, user-granted permissions, etc.</li>
<li><strong>META-INF</strong>: This folder contains metadata of application:</li>
<li>MANIFEST.MF: stores hashes of application resources.</li>
<li>CERT.RSA: The certificate(s) of the application.</li>
<li>CERT.SF: The list of resources and SHA-1 digest of the corresponding lines in the MANIFEST.MF file.</li>
<li><strong>assets</strong>: A directory containing applications assets (files used within the Android App like XML, Java Script or pictures) which can be retrieved by the AssetManager.</li>
<li><strong>classes.dex</strong>: The classes compiled in the DEX file format understandable by the Dalvik virtual machine/Android Runtime. DEX is Java Byte Code for Dalvik Virtual Machine. It is optimized for running on small devices.</li>
<li><strong>lib</strong>: A directory containting libraries that are part of the APK, for example 3rd party libraries that are not part of the Android SDK.</li>
<li><strong>res</strong>: A directory containing resources not compiled into resources.arsc.</li>
<li><strong>resources.arsc</strong>: A file containing precompiled resources, such as XML files for the layout.</li>
</ul>
<p>Since some resources inside the APK are compressed using non-standard algorithms (e.g. the AndroidManifest.xml), simply unzipping the file does not reveal all information. A better way is to use the tool apktool to unpack and uncompress the files. The following is a listing of the the files contained in the apk:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">apktool</span> d base.apk
<span class="kw">I</span>: Using Apktool 2.1.0 on base.apk
<span class="kw">I</span>: Loading resource table...
<span class="kw">I</span>: Decoding AndroidManifest.xml with resources...
<span class="kw">I</span>: Loading resource table from file: /Users/sven/Library/apktool/framework/1.apk
<span class="kw">I</span>: Regular manifest package...
<span class="kw">I</span>: Decoding file-resources...
<span class="kw">I</span>: Decoding values */* XMLs...
<span class="kw">I</span>: Baksmaling classes.dex...
<span class="kw">I</span>: Copying assets and libs...
<span class="kw">I</span>: Copying unknown files...
<span class="kw">I</span>: Copying original files...
$ <span class="kw">cd</span> base
$ <span class="kw">ls</span> -alh
<span class="kw">total</span> 32
<span class="kw">drwxr-xr-x</span>    9 sven  staff   306B Dec  5 16:29 .
<span class="kw">drwxr-xr-x</span>    5 sven  staff   170B Dec  5 16:29 ..
<span class="kw">-rw-r--r--</span>    1 sven  staff    10K Dec  5 16:29 AndroidManifest.xml
<span class="kw">-rw-r--r--</span>    1 sven  staff   401B Dec  5 16:29 apktool.yml
<span class="kw">drwxr-xr-x</span>    6 sven  staff   204B Dec  5 16:29 assets
<span class="kw">drwxr-xr-x</span>    3 sven  staff   102B Dec  5 16:29 lib
<span class="kw">drwxr-xr-x</span>    4 sven  staff   136B Dec  5 16:29 original
<span class="kw">drwxr-xr-x</span>  131 sven  staff   4.3K Dec  5 16:29 res
<span class="kw">drwxr-xr-x</span>    9 sven  staff   306B Dec  5 16:29 smali</code></pre></div>
<ul>
<li><strong>AndroidManifest.xml</strong>: This file is not compressed anymore and can be openend in a text editor.</li>
<li><strong>apktool.yml</strong> : This file contains information about the output of apktool.</li>
<li><strong>assets</strong>: A directory containing applications assets (files used within the Android App like XML, Java Script or pictures) which can be retrieved by the AssetManager.</li>
<li><strong>lib</strong>: A directory containting libraries that are part of the APK, for example 3rd party libraries that are not part of the Android SDK.</li>
<li><strong>original</strong>: TBD</li>
<li><strong>res</strong>: A directory containing resources not compiled into resources.arsc.</li>
<li><strong>smali</strong>: A directory containing the disassembled Dalvik Bytecode in Smali. Smali is a human readable representation of the Dalvik executable.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://source.android.com/security/">Android Security</a></li>
<li><a href="https://source.android.com/devices/">HAL</a></li>
<li>&quot;Android Security: Attacks and Defenses&quot; By Anmol Misra, Abhishek Dubey</li>
</ul>
<h2 id="ios">iOS</h2>
<p>(...TODO...)</p>
<p>As every platform, also iOS provides a SDK (Software Development Kit) that helps developers to develop, install, run and test native iOS Apps by offering different tools and interfaces. iOS applications are implemented either by using Objective-C or Swift.</p>
<p>Objective-C is an object-oriented programming language that is based on C and is used on macOS and iOS to develop (mobile) applications. Even macOS and iOS itself is mainly implemented by using Objective-C.</p>
<p>Swift is the successor of Objective-C and allows interoperability with the same and was introduced with Xcode 6 in 2014.</p>
<h3 id="ios-security-architecture">iOS Security Architecture</h3>
<p>(...TODO...)</p>
<p><img src="http://bb-conservation.de/sven/iOS_Security_Architecture.png" alt="iOS Security Architecture (iOS Security Guide)" /><br />
<em>iOS Security Architecture (iOS Security Guide)</em></p>
<h3 id="structure-of-an-ios-application">Structure of an iOS Application</h3>
<p>iOS applications are distributed in IPA (iOS App Store Package) archives. This IPA file contains all the necessary (for ARM compiled) application code and resources required to execute the application. The container is in fact a ZIP compressed file, which can be easily decompressed.<br />
An IPA has a built-in structure for iTunes and App Store to recognize, The example below shows the high level structure of an IPA.</p>
<ul>
<li>/Payload/ folder contains all the application data. We will come back to the content of this folder in more detail.</li>
<li>/Payload/Application.app contains the application data itself (ARM compiled code) and associated static resources</li>
<li>/iTunesArtwork is a 512x512 pixel PNG images used as the application’s icon</li>
<li>/iTunesMetadata.plist contains various bits of information, ranging from the developer's name and ID, the bundle identifier, copyright information, genre, the name of the app, release date, purchase date, etc.</li>
<li>/WatchKitSupport/WK is an example of an extension bundle. This specific bundle contains the extension delegate and the controllers for managing the interfaces and for responding to user interactions on an Apple watch.</li>
</ul>
<h3 id="app-installation-process">App Installation Process</h3>
<p>Different methods exist to install an IPA package on the device. The easiest solution is to use iTunes, which is the default media player from Apple. ITunes Packages exist for OS X as well as for Windows. iTunes allows you to download applications through the App Store, after which you can synchronise them to an iOS device. The App store is the official application distribution platform from Apple. You can also use iTunes to load an ipa to a device. This can be done by adding “dragging” it into the Apps section, after which we can then add it to a device.</p>
<p>On Linux we can make use of libimobiledevice, a cross-platform software protocol library and set of tools to communicate with iOS devices natively. Through ideviceinstaller we can install packages over an USB connection. The connection is implemented using USB multiplexing daemon [usbmuxd] which provides a TCP tunnel over USB. During normal operations, iTunes communicates with the iPhone using this usbmux, multiplexing several “connections” over the one USB pipe. Processes on the host machine open up connections to specific, numbered ports on the mobile device. [usbmux]</p>
<p>On the iOS device, the actual installation process is then handled by installd daemon, which will unpack and install it. Before your app can integrate app services, be installed on a device, or be submitted to the App Store, it must be signed with a certificate issued by Apple. This means that we can only install it after the code signature is valid. On a jailbroken phone this can however be circumvented using [AppSync], a package made available on the Cydia store. This is an alternate app store containing a lot of useful applications which leverage root privileges provided through the jailbreak in order to execute advanced functionalities. AppSync is a tweak that patches installd to allow for the installation of fake-signed IPA packages.</p>
<p>The IPA can also be installed directly from command line by using [ipainstaller]. After copying the IPA onto the device, for example by using scp (secure copy), the ipainstaller can be executed with the filename of the IPA:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ipainstaller</span> App_in_scope.ipa</code></pre></div>
<h4 id="app-folder-structure-1">App Folder Structure</h4>
<p>Since iOS 8, changes were made to the way an application is stored on the device. On versions before iOS 8, applications would be unpacked to a folder in the /var/mobile/applications/ folder. The application would be identified by its UUID (Universal Unique Identifier), a 128-bit number. This would be the name of the folder in which we will find the application itself. Since iOS 8 this has changed however, so we will see that the static bundle and the application data folders are now stored in different locations on the filesystem. These folders contain information that we will need to closely examine during application security assessments.</p>
<ul>
<li>/var/mobile/Containers/Bundle/Application/[UUID]/Application.app contains the previously mentioned application.app data and stores the static content as well as the ARM compiled binary of the application. The content of this folder will be used to validate the code signature.</li>
<li>/var/mobile/Containers/Data/Application/[UUID]/Documents contains all the data stored for the application itself. The creation of this data is initiated by the application’s end user.</li>
<li>/var/mobile/Containers/Data/Application/[UUID]/Library contains files necessary for the application e.g. caches, preferences, cookies, property list (plist) configuration files, etc.</li>
<li>/var/mobile/Containers/Data/Application/[UUID]/Temp contains temporary files which do not need persistence in between application launches.</li>
</ul>
<p>The following figure represents the application’s folder structure:</p>
<p><img src="http://bb-conservation.de/sven/iOS.png" alt="iOS App Folder Structure" /></p>
<h4 id="ipa-payloads---a-closer-look">IPA Payloads - A Closer Look</h4>
<p>Let’s take a closer look now at the different files that are to be found in the ZIP compressed IPA container. It is necessary to understand that this is the raw architecture of the bundle container and not the definitive form after installation on the device. It uses a relatively flat structure with few extraneous directories in an effort to save disk space and simplify access to the files. The bundle contains the application executable and any resources used by the application (for instance, the application icon, other images, and localized content) in the top-level bundle directory.</p>
<ul>
<li><strong>MyApp</strong>: The executable containing the application’s code, which is compiled and not in a ‘readable’ format.</li>
<li><strong>Application</strong>: Icons used at specific times to represent the application.</li>
<li><strong>Info.plist</strong>: Containing configuration information, such as its bundle ID, version number, and display name.</li>
<li><strong>Launch images</strong>: Images showing the initial interface of the application in a specific orientation. The system uses one of the provided launch images as a temporary background until the application is fully loaded.</li>
<li><strong>MainWindow.nib</strong>: Contains the default interface objects to load at application launch time. Other interface objects are then either loaded from additional nib files or created programmatically by the application.</li>
<li><strong>Settings.bundle</strong>: Contains any application-specific preferences using property lists and other resource files to configure and display them.</li>
<li><strong>Custom resource files</strong>: Non-localized resources are placed at the top level directory and localized resources are placed in language-specific subdirectories of the application bundle. Resources consist of nib files, images, sound files, configuration files, strings files, and any other custom data files you need for your application.</li>
</ul>
<p>A language.lproj folder is defined for each language that the application supports. It contains the a storyboard and strings files.</p>
<ul>
<li>A storyboard is a visual representation of the user interface of an iOS application, showing screens of content and the connections between those screens.</li>
<li>The strings file format consists of one or more key-value pairs along with optional comments.</li>
</ul>
<p><img src="http://bb-conservation.de/sven/iOS_project_folder.png" alt="iOS App Folder Structure" /></p>
<p>On a jailbroken device, you can recover the IPA for an installed iOS app using IPA Installer (see also <a href="Document/0x05b-Testing-Process-and-Techniques-iOS.md">Testing Processes and Techniques</a>). Note that during mobile security assessments, developers will often provide you with the IPA directly. They could send you the actual file, or provide access to the development specific distribution platform they use e.g. [HockeyApp] or [Testflight].</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007898-CH1-SW1">iOS Technology Overview</a></li>
<li><a href="https://www.apple.com/business/docs/iOS_Security_Guide.pdf">iOS Security Guide</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/705/">How iOS Security Really Works</a></li>
<li><a href="http://www.libimobiledevice.org/">usbmuxd</a></li>
<li><a href="http://wikee.iphwn.org/usb:usbmux">usbmux</a></li>
<li><a href="https://cydia.angelxwind.net/?page/net.angelxwind.appsyncunified">AppSync</a></li>
<li><a href="https://github.com/autopear/ipainstaller">ipainstaller</a></li>
<li><a href="https://hockeyapp.net/">Hockey Flight</a></li>
<li><a href="https://developer.apple.com/testflight/">Testflight</a></li>
</ul>
<h1 id="testing-processes-and-techniques">Testing Processes and Techniques</h1>
<h2 id="black-box-testing">Black-box Testing</h2>
<h2 id="white-box-testing">White-box Testing</h2>
<h2 id="static-analysis">Static Analysis</h2>
<h2 id="dynamic-analysis">Dynamic Analysis</h2>
<h2 id="android-1">Android</h2>
<h3 id="white-box-testing-1">White-box Testing</h3>
<h3 id="black-box-testing-1">Black-box Testing</h3>
<h2 id="ios-1">iOS</h2>
<h3 id="white-box-testing-2">White-box Testing</h3>
<h3 id="black-box-testing-2">Black-box Testing</h3>
<h4 id="recovering-an-ipa-file-from-an-installed-app">Recovering an IPA file from an installed app</h4>
<p>You can use Saurik's IPA Installer to recover IPAs from apps installed on the device. To do this, install <a href="http://cydia.saurik.com/package/com.autopear.installipa/">IPA installer console</a> via Cydia. Then, ssh into the device and look up the bundle id of the target app. For example:</p>
<pre><code>iPhone:~ root# ipainstaller -l
com.apple.Pages
com.example.targetapp
com.google.ios.youtube
com.spotify.client</code></pre>
<p>Generate the IPA file for using the following command:</p>
<pre><code>iPhone:~ root# ipainstaller -b com.example.targetapp -o /tmp/example.ipa</code></pre>
<p>References:</p>
<p><a href="http://cydia.saurik.com/package/com.autopear.installipa/" class="uri">http://cydia.saurik.com/package/com.autopear.installipa/</a></p>
<h1 id="tampering-and-reverse-engineering">Tampering and Reverse Engineering</h1>
<p>Reverse engineering and tampering techniques have long belonged into the realm of crackers, modders, malware analysts, and other more exotic professions. For &quot;traditional&quot; security testers and researchers, reverse engineering has been more of a complementary, nice-to-have-type skill that wasn't all that useful in 99% of day-to-day work. But the tides are turning: Mobile app black-box testing increasingly requires testers to disassemble compiled apps, apply patches, and tamper with binary code or even live processes. The fact that many mobile apps implement defenses against unwelcome tampering doesn't make things easier for us.</p>
<p>Mobile security testers should be able to understand basic reverse engineering concepts. It goes without saying that they should also know mobile devices and operating systems inside out: The processor architecture, executable format, programming language intricacies, and so forth.</p>
<p>Reverse engineering is an art, and describing every available facet of it would fill a whole library. The sheer range techniques and possible specializations is mind-blowing: One can spend years working on a very specific, isolated sub-problem, such as automating malware analysis or developing novel de-obfuscation methods. Security testers are generalists: To be effective reverse engineers, they must be able filter through the vast amount of information to build a workable methodology.</p>
<p>There is no generic reverse engineering process that always works. That said, we'll describe commonly used methods and tools later on, and give examples for tackling the most common defenses.</p>
<h2 id="why-should-you-even-bother">Why Should You Even Bother?</h2>
<p>To sum things up, mobile security testing requires at least basic reverse engineering skills for several reasons:</p>
<p><strong>1. To enable black-box testing of mobile apps.</strong> Modern apps often employ technical controls that will hinder your ability to perform dynamic analysis. SSL pinning and E2E encryption could prevent you from intercepting or manipulating traffic with a proxy. Root detection could prevent the app from running on a rooted device, preventing you from using advanced testing tools. In this cases, you must be able to deactivate these defenses.</p>
<p><strong>2. To enhance static analysis in black-box security testing.</strong> In a black-box test, static analysis of the app bytecode or binary code is helpful for getting a better understanding of what the app is doing. It also enables you to identify certain flaws, such as credentials hardcoded inside the app.</p>
<p><strong>3. To assess resiliency against reverse engineering.</strong> Apps that implement software protections according to MASVS L3 or L4 should be resilient against reverse engineering. In this case, testing the reverse engineering defenses (&quot;resiliency assessment&quot;) is part of the overall security test. In the resiliency assessment, the tester assumes the role of the reverse engineer and attempts to bypass the defenses. Advanced reverse engineering skills are required to perform this kind of test.</p>
<h2 id="before-you-start">Before You Start</h2>
<h2 id="basic-tampering-techniques">Basic Tampering Techniques</h2>
<p>Tampering is the process of making changes to a mobile app either the compiled app, or the running process) or its environment to affect changes in its behavior. For example, and app might refuse to running on your rooted test device, making it impossible to run some of your tests. In cases like that, you'll want to alter that particular behavior.</p>
<p>In the following section we'll give a high level overview of the techniques most commonly used in mobile app security testing. Later, we'll drill down into OS-specific details for both Android and iOS.</p>
<h3 id="binary-patching">Binary Patching</h3>
<p>Patching means making changes to the compiled app - e.g. changing code in a binary executable file(s), modifying Java bytecode, or tampering with resources. Patches can be applied in any number of ways, from decompiling and re-assembling an app, to editing binary files in a hex editor - anything goes (this rule applies to all of reverse engineering). We'll give some detailed examples for useful patches in later chapters.</p>
<p>One thing to keep in mind is that modern mobile OSes strictly enforce code signing, so running modified apps is not as straightforward as it used to be in traditional Desktop environments. Yep, security experts had a much easier life in the 90ies! Fortunately, this is not all that difficult to do if you work on your own device - it simply means that you need to re-sign the app, or disable the default code signing facilities to run modified code.</p>
<h3 id="runtime-modifications">Runtime Modifications</h3>
<p>Code injection is a very powerful technique that allows you to explore and modify processes during runtime. The injection process can be implemented in various ways*, but you'll get by without knowing all the details thanks to freely available, well-documented tools that automate it. These tools give you direct access to process memory and important structures such as live objects instantiated by the app, and come with many useful utility functions for resolving loaded libraries, hooking methods and native functions, and more. Tampering with process memory is more difficult to detect than patching files, making in the preferred method in the majority of cases.</p>
<p>Substrate, Frida and XPosed are the most widely used code injection frameworks. The three frameworks differ in design philosophy and implementation details: Substrate and Xposed only focus on code injection and hooking, while Frida aims to be a full-blown &quot;dynamic instrumentation framework&quot; that incorporates both code injection and language bindings, as well as an injectable JavaScript VM and console. Substrate however does provide code injection support for Cycrypt, the programming environment (a.k.a. &quot;Cycript-to-JavaScript&quot; compiler) authored by Saurik of Cydia fame.</p>
<h4 id="substrate-frida-and-xposed">Substrate, Frida and Xposed</h4>
<p>Cydia Substrate (formerly called MobileSubstrate) is the de-facto framework for developing run-time patches (“Cydia Substrate extensions”) on iOS. It comes with Cynject, a tool that provides code injection support for C. By injecting a JavaScriptCore VM into a running process on iOS, users can interface with C code, with support for primitive types, pointers, structs and C Strings, as well as Objective-C objects and data structures. It is also possible to access and instantiate Objective-C classes inside a running process. Some examples for the use of Cycript are listed in the iOS chapter.</p>
<p>Xposed is another popular code injection framework for Android. Installing Xposed on a rooted Android device allows you to apply runtime modifications to processes. The Xposed framework is described in more detail in the <a href="/Document/0x06a-Reverse-Engineering-and-Tampering-Android.md">Android Reverse Engineering</a> chapter.</p>
<p>Frida is a dynamic instrumentation framework that lets the user you inject JavaScript into native apps on Windows, Mac, Linux, iOS, Android, and QNX. We'll cover Frida in a bit more detail below.</p>
<p>To complicate things, Frida's authors also created a fork of Cycript named <a href="https://github.com/nowsecure/frida-cycript">&quot;frida-cycript&quot;</a> that replaces Cycript's runtime with a Frida-based runtime called Mjølner. This enables Cycript run on all the platforms and architectures maintained by frida-core. The release was accompanies by a blog post by Ole titled &quot;Cycript on Steroids&quot;, which prompted a vitriolic response by Saurik on <a href="https://www.reddit.com/r/ReverseEngineering/comments/50uweq/cycript_on_steroids_pumping_up_portability_and/">Reddit</a>.</p>
<p>Ultimately, you can achieve many of the same goals with either framework. Frida is however the most versatile, as it can inject a Javascript VM on both Android and iOS, while Cycript injection with Substrate only works on iOS.</p>
<h4 id="dynamic-instrumentation-with-frida">Dynamic Instrumentation with Frida</h4>
<p>Code injection can be achieved in different ways. For example, Xposed makes some permanent modifications to the Android app loader that provide hooks to run your own code every time a new process is started. In contrast, Frida achieves code injection by writing code directly into process memory. The process is outlined in a bit more detail below.</p>
<p>When you &quot;attach&quot; Frida to a running app, it uses ptrace to hijack a thread in a running process. This thread is used to allocate a chunk of memory and populate it with a mini-bootstrapper. The bootstrapper starts a fresh thread, connects to the Frida debugging server running on the device, and loads a dynamically generated library file containing the Frida agent and instrumentation code. The original, hijacked thread is restored to its original state and resumed, and execution of the process continues as usual.</p>
<p>Frida injects a complete JavaScript runtime into the process, along with a powerful API that provides a wealth of useful functionality, including calling and hooking of native functions and injecting structured data into memory. It also supports interaction with the Android Java runtime, such as interacting with objects inside the VM.</p>
<p><img src="images/frida.png" alt="Frida" /></p>
<p>*FRIDA Architecture, source: <a href="http://www.frida.re/docs/hacking/*" class="uri">http://www.frida.re/docs/hacking/*</a></p>
<p>(todo... add some Frida console examples and links)</p>
<h2 id="static-dynamic-binary-analysis">Static / Dynamic Binary Analysis</h2>
<p>Reverse engineering is the process of reconstructing the semantics of the original source code from a compiled program. In other words, you take the program apart, run it, simulate parts of it, and do other unspeakable things to in order to understand what exactly it is doing and how.</p>
<h3 id="using-disassemblers-and-decompilers">Using Disassemblers and Decompilers</h3>
<p>Disassemblers and decompilers allow you to translate an app's binary code or byte-code back into a more or less understandable format. In the case of native binaries, you'll usually obtain assembler code matching the architecture the app was compiled for. Android Java apps can be disassembled to Smali (an Assembler language for the dex format), and also quite easily converted back to Java code.</p>
<p>TODO: introduce a few standard tools, IDA Pro Hopper, Radare2, JEB (?)</p>
<p>TODO: Talk about IDA Scripting and the many plugins developed by the community</p>
<h3 id="debugging">Debugging</h3>
<h3 id="execution-tracing">Execution Tracing</h3>
<h3 id="dynamic-binary-instrumentation">Dynamic Binary Instrumentation</h3>
<p>Another useful method for dealing with native binaries is dynamic binary instrumentations (DBI). Instrumentation frameworks such as Valgrind and PIN support fine-grained instruction-level tracing of single processes. This is achieved by inserting dynamically generated code at runtime. Valgrind compiles fine on Android, and pre-built binaries are available for download. The <a href="http://valgrind.org/docs/manual/dist.readme-android.html">Valgrind README</a> contains specific compilation instructions for Android.</p>
<h2 id="automated-de-obfuscation-attacks">Automated De-Obfuscation Attacks</h2>
<p>TODO: Introduce advanced concepts</p>
<h3 id="binary-analysis-frameworks">Binary Analysis Frameworks</h3>
<p>TODO: Introduce RE frameworks</p>
<p><a href="https://github.com/cea-sec/miasm">Miasm</a><br />
<a href="https://github.com/jjyg/metasm">Metasm</a></p>
<h3 id="symbolic-execution">Symbolic Execution</h3>
<h3 id="domain-specific-attacks">Domain-specific attacks</h3>
<h2 id="tampering-and-reverse-engineering-on-android">Tampering and Reverse Engineering on Android</h2>
<p>Its openness makes Android a favorable environment for reverse engineers. However, dealing with both Java and native code can make things more complicated at times. In the following chapter, we'll look at some peculiarities of Android reversing and OS-specific tools as processes.</p>
<h3 id="basics">Basics</h3>
<p>In comparison to iOS, Android offers some big advantages to reverse engineers. First of all transparency: You can study the source code of the Android Open Source Project (AOSP), build your ROMs, and so on. The OS is also much more friendly to developers and tinkerers in other way: From the developer options available by default, to the way debugging is set up and the tools shipping with the SDK, there's lot of niceties to make your life easier compared to &quot;some other vendors&quot;.</p>
<p>However, there's also a few challenges you'll encounter. For example, if you're used to analyzing native code, you'll need to add Java bytecode to your repertoire. As it is easy for developers to call into native code via the Java Native Interface (JNI), you'll often need to work with Java and native code at the same time. JNI is sometimes used on purpose to confuse reverse engineers (to be fair, there might also be legitimate reasons for using JNI, such as improving performance or supporting legacy code). Developers seeking to impede reverse engineering deliberately split functionality between Java bytecode and native code, structuring their apps such that execution frequently jumps between the two layers.</p>
<p>Android reverse engineers need to understand both Java bytecode and ARM assembler, and have a working knowledge about both the Java-based Android environment and the Linux OS and Kernel that forms the basis of Android (better yet, they’d know all these things inside out). Plus, they need the right toolset to deal with both native code and bytecode running inside the Java virtual machine.</p>
<h3 id="environment-and-toolset">Environment and Toolset</h3>
<p>With a little effort you can build a reasonable reverse engineering environment for free. JD is a free Java de-compiler that integrates with Eclipse and IntelliJ. Generally, IntelliJ is the more light-weight solution and works great for browsing the source code and also allows for basic on-device debugging of the decompiled apps.</p>
<p>If you don’t mind looking at SMALI instead of Java code, you can use the smalidea plugin for IntelliJ for debugging on the device. According to the website, Smalidea supports single-stepping through the bytecode, identifier renaming and watches for non-named registers, which makes it much more powerful than a JD + IntelliJ setup.</p>
<p>APKTool is a mandatory utility for dealing with APK archives. It can extract and disassemble resources directly from the APK archive, and can disassemble Java bytecode to SMALI. It also allows you to reassemble the APK package, which is useful for patching and making changes to the Manifest.<br />
<a href="https://github.com/JesusFreke/smali" class="uri">https://github.com/JesusFreke/smali</a></p>
<p>IDA Pro understands ARM, MIPS and of course Intel ELF binaries, plus it can deal with Java bytecode. It also comes with remote debuggers for both Java applications and native processes. With its great disassembler and powerful scripting and extension capabilities, IDA Pro is the unbeaten king for static analysis of native programs and libraries. However, the static analysis facilities it offers for Java code are somewhat basic – you get the SMALI disassembly but not much more. There’s no navigating the package and class structure, and some things (such as renaming classes) can’t be done which can make working with larger obfuscated apps a bit tedious.</p>
<p>This is where dedicated Java de-compilers become useful. JEB, a commercial decompiler, outs all the functionality one might need in a convenient-to-use all-in-one package, is reasonably reliable and you get quick support. It also has a built-in debugger, which allows for an efficient workflow – setting breakpoints directly in the annotated sources is invaluable, especially when dealing with ProGuard-obfuscated bytecode. Unfortunately, convenience like this doesn’t come cheap - at $90 / month for the standard license, JEB isn’t exactly a steal.</p>
<p>-- TODO: Other tools</p>
<p>Some things that should be mentioned:</p>
<ul>
<li>Android SDK</li>
<li>Smali and Baksmali</li>
<li>Androguard</li>
<li>apktool</li>
<li>ADB</li>
<li>DexDump</li>
<li>dex2jar</li>
</ul>
<h3 id="manipulating-android-apps">Manipulating Android Apps</h3>
<h4 id="patching-and-re-packaging">Patching and Re-Packaging</h4>
<h5 id="example-1-repackaging-an-app-for-debugging">Example 1: Repackaging an App for Debugging</h5>
<ol>
<li>Use apktool to restore AndroidManifest.xml:</li>
</ol>
<pre><code>$ apktool d --no-src target_app.apk</code></pre>
<ol>
<li>Add android:debuggable = “true” to the manifest:</li>
</ol>
<pre><code>&lt;application android:allowBackup=&quot;true&quot; android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;com.xxx.xxx.xxx&quot; android:theme=&quot;@style/AppTheme&quot;&gt;</code></pre>
<ol>
<li>Repackage and sign the APK:</li>
</ol>
<pre><code>$ apktool b

$ zipalign -v 4 target_app.recompiled.apk  target_app.recompiled.aligned.apk

$ keytool -genkey -v -keystore ~/.android/debug.keystore -alias signkey -keyalg RSA -keysize 2048 -validity 20000

$ jarsigner -verbose -keystore ~/.android/debug.keystore  target_app.recompiled.aligned.apk signkey</code></pre>
<ol>
<li>Reinstall the app:</li>
</ol>
<pre><code>$ adb install target_app.recompiled.aligned.apk</code></pre>
<h5 id="example-2-disabling-ssl-pinning">Example 2: Disabling SSL Pinning</h5>
<p>As seen in the previous Chapter, certificate pinning might hinder an analyst when analyzing the traffic. To help with this problem, the binary can be patched to allow other certificates. To demonstrate how Certificate Pinning can be bypassed, we will walk through the necessary steps to bypass Certificate Pinning implemented in an example application.<br />
Disassembling the APK using apktool</p>
<pre><code>$ apktool d target_apk.apk</code></pre>
<p>Modify the Certificate Pinning logic:<br />
We need to locate where within the smali source code the certificate pinning checks are done. Searching the smali code for keywords such as “X509TrustManager” should point you in the right direction.<br />
In this case a search for “X509TrustManager” returned one class which implements an own Trustmanager. This file contains methods named “checkClientTrusted”, “checkServerTrusted” and “getAcceptedIssuers”.<br />
The “return-void” opcode was added to the first line of each of these methods. The “return-void” statement is a Dalvik opcode to return ‘void’ or null. For more Dalvik opcodes refer to <a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html" class="uri">http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html</a>.<br />
In this context, return-void means that no certificate checks are performed and the application will accept all certificates.</p>
<p><img src="images/patching-sslpinning.jpg" alt="Screenshot showing the inserted opcode." /></p>
<h4 id="hooking-java-methods-with-xposed">Hooking Java methods with Xposed</h4>
<p>Xposed is a <a href="http://repo.xposed.info/module/de.robv.android.xposed.installer">&quot;framework for modules that can change the behavior of the system and apps without touching any APKs:&quot;&quot;</a>. Technically, it is an extended version of Zygote that exports APIs for running Java code when a new process is started. By running Java code in the context of the newly instantiated app, it is possible to resolve, hook and override Java methods belonging to the app. Xposed uses <a href="https://docs.oracle.com/javase/tutorial/reflect/">reflection</a> to examine and modify the running app. Changes are applied in memory and persist only during the runtime of the process - no patches to the application files are made.</p>
<p>To use Xposed, you first need to install the Xposed framework on a rooted device. Modifications are then deployed in the form of separate apps (&quot;modules&quot;) that can be toggled on and off in the Xposed GUI.</p>
<h5 id="example-bypassing-root-detection">Example: Bypassing Root Detection</h5>
<p>Let's assume you're testing an app that is stubbornly quitting on your rooted device. You decompile the app and find the following highly suspect method:</p>
<pre><code>
package com.example.a.b

public static boolean c() {
  int v3 = 0;
  boolean v0 = false;

  String[] v1 = new String[]{&quot;/sbin/&quot;, &quot;/system/bin/&quot;, &quot;/system/xbin/&quot;, &quot;/data/local/xbin/&quot;,
    &quot;/data/local/bin/&quot;, &quot;/system/sd/xbin/&quot;, &quot;/system/bin/failsafe/&quot;, &quot;/data/local/&quot;};

    int v2 = v1.length;

    for(int v3 = 0; v3 &lt; v2; v3++) {
      if(new File(String.valueOf(v1[v3]) + &quot;su&quot;).exists()) {
         v0 = true;M
         return v0;
      }
    }

    return v0;
}</code></pre>
<p>This method iterates through a list of directories, and returns &quot;true&quot; (device rooted) if the &quot;su&quot; binary is found in any of them. Checks like this are easy to deactivate - all we have to do is to replace the code with something that returns &quot;false&quot;.</p>
<p>Using an Xposed module is one way to do this. Modules for Xposed are developed and deployed with Android Studio just like regular Android apps. The author, rovo89, provides a great <a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial">tutorial</a> showing how to write, compile and install a module.</p>
<p>Code:</p>
<pre><code>
package com.awesome.pentestcompany;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XposedBridge;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;

public class DisableRootCheck implements IXposedHookLoadPackage {

    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
        if (!lpparam.packageName.equals(&quot;com.example.targetapp&quot;))
            return;

        findAndHookMethod(&quot;com.example.a.b&quot;, lpparam.classLoader, &quot;c&quot;, new XC_MethodHook() {
            @Override

            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                XposedBridge.log(&quot;Caught root check!&quot;);
                param.setResult(false);
            }

        });
    }
}
</code></pre>
<h4 id="code-injection-with-frida">Code Injection with FRIDA</h4>
<p>Here are some more APIs FRIDA offers on Android:</p>
<ul>
<li>Instantiate Java objects and call static and non-static class methods;</li>
<li>Replace Java method implementations;</li>
<li>Enumerate live instances of specific classes by scanning the Java heap (Dalvik only);</li>
<li>Scan process memory for occurrences of a string;</li>
<li>Intercept native function calls to run your own code at function entry and exit.</li>
</ul>
<p>Some features unfortunately don’t work yet on current Android devices platforms. Most notably, the FRIDA Stalker - a code tracing engine based on dynamic recompilation - does not support ARM at the time of this writing (version 7.2.0). Also, support for ART has been included only recently, so the Dalvik runtime is still better supported.</p>
<h5 id="example-bypassing-native-debugger-detection">Example: Bypassing Native Debugger Detection</h5>
<pre><code>#v0.1
 
import frida
import sys
 
session = frida.get_remote_device().attach(&quot;com.example.targetapp&quot;)
 
script = session.create_script(&quot;&quot;&quot;
 
var funcPtr = Module.findExportByName(&quot;libdvm.so&quot;, &quot;_Z25dvmDbgIsDebuggerConnectedv&quot;);
Interceptor.replace(funcPtr, new NativeCallback(function (pathPtr, flags) {
    return 0;
}, &#39;int&#39;, []));
 
def on_message(message, data):
    print(message)
 
script.on(&#39;message&#39;, on_message)
script.load()
sys.stdin.read()</code></pre>
<h3 id="reverse-engineering-on-android">Reverse Engineering on Android</h3>
<h4 id="statically-analyzing-java-code">Statically Analyzing Java Code</h4>
<p>TODO: Pulling APK File from the device</p>
<p>TODO: DEX vs. OAT</p>
<h4 id="statically-analyzing-native-code">Statically Analyzing Native Code</h4>
<h4 id="debugging-android-apps">Debugging Android Apps</h4>
<h4 id="execution-tracing-1">Execution Tracing</h4>
<p>The JDB command line tool offers basic execution tracing functionality.<br />
To trace an app right from the start we can pause the app using the Android “Wait for Debugger” feature or a kill –STOP command and attach JDB to set a deferred method breakpoint on an initialization method of our choice. Once the breakpoint hits, we activate method tracing with the trace go methods command and resume execution. JDB will dump all method entries and exits from that point on.</p>
<pre><code>Pyramidal-Neuron:DIGIPASS berndt$ adb forward tcp:7777 jdwp:7288
Pyramidal-Neuron:DIGIPASS berndt$ { echo &quot;suspend&quot;; cat; } | jdb -attach localhost:7777
Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable
Initializing jdb ...
&gt; All threads suspended.
&gt; stop in com.acme.bob.mobile.android.core.BobMobileApplication.&lt;clinit&gt;()          
Deferring breakpoint com.acme.bob.mobile.android.core.BobMobileApplication.&lt;clinit&gt;().
It will be set after the class is loaded.
&gt; resume
All threads resumed.M
Set deferred breakpoint com.acme.bob.mobile.android.core.BobMobileApplication.&lt;clinit&gt;()

Breakpoint hit: &quot;thread=main&quot;, com.acme.bob.mobile.android.core.BobMobileApplication.&lt;clinit&gt;(), line=44 bci=0
main[1] trace go methods
main[1] resume
Method entered: All threads resumed.</code></pre>
<p>The Dalvik Debug Monitor Server (DDMS) a GUI tool included with Android Studio. At first glance it might not look like much, but make no mistake: Its Java method tracer is one of the most awesome tools you can have in your arsenal, and is indispensable for analyzing obfuscated bytecode.</p>
<p>Using DDMS is a bit confusing however: It can be launched in several ways, and different trace viewers will be launched depending on how the trace was obtained. There’s a standalone tool called “Traceview” as well as a built-in viewer in Android Studio, both of which offer different ways of navigating the trace. You’ll usually want to use the viewer built into Android studio (which I didn’t know about for several weeks until I discovered it by accident) which gives you a nice, zoom-able hierarchical timeline of all method calls. The standalone tool however is also useful, as it has a profile panel that shows the time spent in each method, as well as the parents and children of each method.</p>
<p>To record an execution trace in Android studio, open the “Android” tab at the bottom of the GUI. Select the target process in the list and the click the little “stop watch” button on the left. This starts the recording. Once you are done, click the same button to stop the recording. The integrated trace view will open showing the recorded trace. You can scroll and zoom the timeline view using the mouse or trackpad.</p>
<p>Alternatively, execution traces can also be recorded in the standalone Android Device Monitor. The Device Monitor can be started from within Android Studo (Tools -&gt; Android -&gt; Android Device Monitor) or from the shell with the ddms command.<br />
To start recording tracing information, select the target process in the “Devices” tab and click the “Start Method Profiling” button. Click the stop button to stop recording, after which the Traceview tool will open showing the recorded trace. An interesting feature of the standalone tool is the “profile” panel on the bottom, which shows an overview of the time spent in each method, as well as each method’s parents and children. Clicking any of the methods in the profile panel highlights the selected method in the timeline panel.</p>
<p>As an aside, DDMS also offers convenient heap dump button that will dump the Java heap of a process to a .hprof file. More information on Traceview can be found in the Android Studio user guide.</p>
<h4 id="tracing-system-calls">Tracing System Calls</h4>
<p>Moving down a level in the OS hierarchy, we arrive at privileged functions that require the powers of the Linux kernel. These functions are available to normal processes via the system call interface. Instrumenting and intercepting calls into the kernel is an effective method to get a rough idea of what a user process is doing, and is often the most efficient way to deactivate low-level tampering defenses.</p>
<p>Strace is a standard Linux utility that is used to monitor interaction between processes and the kernel. The utility is not included with Android by default, but can be easily built from source using the Android NDK. This gives us a very convenient way of monitoring system calls of a process. Strace however depends on ptrace() to attach to the target process, so it only works up to the point that anti- debugging measures kick in.</p>
<p>As a side note, if the Android “stop application at startup” feature is unavailable we can use a shell script to make sure that strace attached immediately once the process is launched (not an elegant solution but it works):</p>
<pre><code>while true; do pid=$(pgrep &#39;target_process&#39; | head -1); if [[ -n &quot;$pid&quot; ]]; then strace -s 2000 - e “!read” -ff -p &quot;$pid&quot;; break; fi; done</code></pre>
<h5 id="ftrace">Ftrace</h5>
<p>Ftrace is a tracing utility built directly into the Linux kernel. On a rooted device, ftrace can be used to trace kernel system calls in a more transparent way than is possible with strace, which relies on the ptrace system call to attach to the target process.<br />
Conveniently, ftrace functionality is found in the stock Android kernel on both Lollipop and Marshmallow. It can be enabled with the following command:</p>
<pre><code>echo 1 &gt; /proc/sys/kernel/ftrace_enabled</code></pre>
<p>The /sys/kernel/debug/tracing directory holds all control and output files and related to ftrace. The following files are found in this directory:</p>
<ul>
<li>available_tracers: This file lists the available tracers compiled into the kernel.</li>
<li>current_tracer: This file is used to set or display the current tracer.</li>
<li>tracing_on: Echo 1 into this file to allow/start update of the ring buffer. Echoing 0 will prevent further writes into the ring buffer.</li>
</ul>
<h5 id="kprobes">KProbes</h5>
<p>The KProbes interface provides us with an even more powerful way to instrument the kernel: It allows us to insert probes into (almost) arbitrary code addresses within kernel memory. Kprobes work by inserting a breakpoint instruction at the specified address. Once the breakpoint is hit, control passes to the Kprobes system, which then executes the handler function(s) defined by the user as well as the original instruction. Besides being great for function tracing, KProbes can be used to implement rootkit-like functionality such as file hiding.</p>
<p>Jprobes and Kretprobes are additional probe types based on Kprobes that allow hooking of function entries and exits.</p>
<p>Unfortunately, the stock Android kernel comes without loadable module support, which is a problem given that Kprobes are usually deployed as kernel modules. Another issue is that the Android kernel is compiled with strict memory protection which prevents patching some parts of Kernel memory. Using Elfmaster’s system call hooking method (5) results in a Kernel panic on default Lolllipop and Marshmallow due to sys_call_table being non-writable. We can however use Kprobes on a sandbox by compiling our own, more lenient Kernel (more on this later).</p>
<h4 id="emulation-based-analysis">Emulation-based Analysis</h4>
<p>Running an app in the emulator gives us powerful ways to monitor and manipulate its environment. For some reverse engineering tasks, especially those that require low-level instruction tracing, emulation is the best (or only) choice.</p>
<p>Even in its standard form that ships with the Android SDK, the Android emulator – a.k.a. “emulator” - is a somewhat capable reverse engineering tool. It is based on QEMU, a generic and open source machine emulator. QEMU emulates a guest CPU by translating the guest instructions on-the-fly into instructions the host processor can understand. Each basic block of guest instructions is disassembled and translated into an intermediate representation called Tiny Code Generator (TCG). The TCG block is compiled into a block of host instructions, stored into a code cache, and executed. After execution of the basic block has completed, QEMU repeats the process for the next block of guest instructions (or loads the already translated block from the cache). The whole process is called dynamic binary translation.</p>
<p>Because the Android emulator is a fork of QEMU, it comes with the full QEMU feature set, including its monitoring, debugging and tracing facilities. QEMU-specific parameters can be passed to the emulator with the -qemu command line flag. We can use QEMU’s built-in tracing facilities to log executed instructions and virtual register values. Simply starting qemu with the &quot;-d&quot; command line flag will cause it to dump the blocks of guest code, micro operations or host instructions being executed. The –d in_asm option logs all basic blocks of guest code as they enter QEMU’s translation function. The following command logs all translated blocks to a file:</p>
<pre><code>emulator -show-kernel -avd Nexus_4_API_19 -snapshot default-boot -no-snapshot-save -qemu -d in_asm,cpu 2&gt;/tmp/qemu.log</code></pre>
<p>Unfortunately, it is not possible to generate a complete guest instruction trace with QEMU, because code blocks are written to the log only at the time they are translated – not when they’re taken from the cache. For example, if a block is repeatedly executed in a loop, only the first iteration will be printed to the log. There’s no way to disable TB caching in QEMU (save for hacking the source code). Even so, the functionality is sufficient for basic tasks, such as reconstructing the disassembly of a natively executed cryptographic algorithm.</p>
<p>Dynamic analysis frameworks, such as PANDA and DroidScope, build on QEMU to provide more complete tracing functionality. PANDA/PANDROID is your best if you’re going for a CPU-trace based analysis, as it allows you to easily record and replay a full trace, and is relatively easy to set up if you follow the build instructions for Ubuntu.</p>
<h5 id="droidscope">DroidScope</h5>
<p>DroidScope is a malware analysis engine based on QEMU. It adds instrumentation on several levels, making it possible to fully reconstruct the semantics on the hardware, Linux and Java level.</p>
<p>DroidScope exports instrumentation APIs that mirror the different context levels (hardware, OS and Java) of a real Android device. Analysis tools can use these APIs to query or set information and register callbacks for various events. For example, a plugin can register callbacks for native instruction start and end, memory reads and writes, register reads and writes, system calls or Java method calls.</p>
<p>All of this makes it possible to build tracers that are practically transparent to the target application (as long as we can hide the fact it is running in an emulator). One limitation is that DroidScope is compatible with the Dalvik VM only.</p>
<p>DroidScope is available as an extension to the DECAF dynamic analysis framework at:</p>
<p><a href="https://github.com/sycurelab/DECAF" class="uri">https://github.com/sycurelab/DECAF</a></p>
<h5 id="panda">PANDA</h5>
<p>PANDA is another QEMU-based dynamic analysis platform. Similar to DroidScope, PANDA can be extended by registering callbacks that are triggered upon certain QEMU events. The twist PANDA adds is its record/replay feature. This allows for an iterative workflow: The reverse engineer records an execution trace of some the target app (or some part of it) and then replays it over and over again, refining his analysis plugins with each iteration.</p>
<p>PANDA comes with some premade plugins, such as a stringsearch tool and a syscall tracer. Most importantly, it also supports Android guests and some of the DroidScope code has even been ported over. Building and running PANDA for Android (“PANDROID”) is relatively straightforward. To test it, clone Moiyx’s git repository14 and build PANDA as follows:MM</p>
<p>As of this writing, Android versions up to 4.4.1 run fine in PANDROID, but anything newer than that won’t boot. Also, the Java level introspection code only works on the specific Dalvik runtime of Android 2.3. Anyways, older versions of Android seem to run much faster in the emulator, so if you plan on using PANDA sticking with Gingerbread is probably best. For more information, check out the extensive documentation in the PANDA git repo:</p>
<p><a href="https://github.com/moyix/panda/blob/master/docs/" class="uri">https://github.com/moyix/panda/blob/master/docs/</a></p>
<h5 id="vxstripper">VxStripper</h5>
<p>Another very useful tool built on QEMU is VxStripper by Sébastien Josse. VXStripper is specifically designed for de-obfuscating binaries. By instrumenting QEMU's dynamic binary translation mechanisms, it dynamically extracts an intermediate representation of a binary. It then applies simplifications to the extracted intermediate representation, and recompiles the simplified binary using LLVM. This is a very powerful way of normalizing obfuscated programs. See Sébastien's paper <a href="http://ieeexplore.ieee.org/document/6759227/">Malware Dynamic Recompilation</a> for more information.</p>
<h4 id="customizing-android">Customizing Android</h4>
<p>Working on real device has advantages especially for interactive, debugger-supported static / dynamic analysis. For one, it is simply faster to work on a real device. Also, being run on a real device gives the target app less reason to be suspicious and misbehave. By instrumenting the live environment at strategic points, we can obtain useful tracing functionality and manipulate the environment to help us bypass any anti-tampering defenses the app might implement.</p>
<h5 id="preparing-a-development-environment">Preparing a development environment</h5>
<p>To get the development environment ready, simply download Google’s Android Studio. It comes with a SDK Manager app that lets you install the Android SDK tools and manage SDKs for various API levels, as well as the emulator and an AVD Manager application to create emulator images. Android Studio can be downloaded from the Android download page:<br />
<a href="https://developer.android.com/develop/index.html" class="uri">https://developer.android.com/develop/index.html</a><br />
You’ll also need the Android NDK for compiling anything that creates native code. The NDK contains prebuilt toolchains for cross-compiling native code for different architectures. The NDK is available as a separate download:<br />
<a href="https://developer.android.com/ndk/downloads/index.html" class="uri">https://developer.android.com/ndk/downloads/index.html</a><br />
After you downloaded the SDK, create a standalone toolchain for Android Lollipop (API 21):</p>
<pre><code>$ $YOUR_NDK_PATH/build/tools/make-standalone-toolchain.sh --arch=arm --platform=android-21 --install-dir=/tmp/my-android-toolchain</code></pre>
<h5 id="customizing-the-ramdisk">Customizing the RAMDisk</h5>
<p>The initramfs is a small CPIO archive stored inside the boot image. It contains a few files that are required at boot time before the actual root file system is mounted. On Android, the initramfs stays mounted indefinitely, and it contains an important configuration file named default.prop that defines some basic system properties. By making some changes to this file, we can make the Android environment a bit more reverse-engineering-friendly.<br />
For our purposes, the most important settings in default.prop are ro.debuggable and ro.secure.</p>
<pre><code>shell@hammerhead:/ $ cat /default.prop                                         
#
# ADDITIONAL_DEFAULT_PROPERTIES
#
ro.secure=1
ro.allow.mock.location=0
ro.debuggable=1
ro.zygote=zygote32
persist.radio.snapshot_enabled=1
persist.radio.snapshot_timer=2
persist.radio.use_cc_names=true
persist.sys.usb.config=mtp
rild.libpath=/system/lib/libril-qc-qmi-1.so
camera.disable_zsl_mode=1
ro.adb.secure=1
dalvik.vm.dex2oat-Xms=64m
dalvik.vm.dex2oat-Xmx=512m
dalvik.vm.image-dex2oat-Xms=64m
dalvik.vm.image-dex2oat-Xmx=64m
ro.dalvik.vm.native.bridge=0</code></pre>
<p>Setting ro.debuggable to 1 causes all apps running on the system to be debuggable (i.e., the debugger thread runs in every process), independent of the android:debuggable attribute in the app’s Manifest. Setting ro.secure to 0 causes adbd to be run as root.<br />
To modify initrd on any Android device, back up the original boot image using TWRP, or simply dump it with a command like:</p>
<pre><code>adb shell cat /dev/mtd/mtd0 &gt;/mnt/sdcard/boot.img
adb pull /mnt/sdcard/boot.img /tmp/boot.img</code></pre>
<p>Use the abootimg tool as described in Krzysztof Adamski’s how-to to extract the contents of the boot image:</p>
<pre><code>mkdir boot
cd boot
../abootimg -x /tmp/boot.img
mkdir initrd
cd initrd
cat ../initrd.img | gunzip | cpio -vid</code></pre>
<p>Take note of the boot parameters written to bootimg.cfg – you will need to these parameters later when booting your new kernel and ramdisk.</p>
<pre><code>berndt@osboxes:~/Desktop/abootimg/boot$ cat bootimg.cfg
bootsize = 0x1600000
pagesize = 0x800
kerneladdr = 0x8000
ramdiskaddr = 0x2900000
secondaddr = 0xf00000
tagsaddr = 0x2700000
name =
cmdline = console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1
Modify default.prop and package your new ramdisk:
cd initrd
find . | cpio --create --format=&#39;newc&#39; | gzip &gt; ../myinitd.img</code></pre>
<h5 id="customizing-the-android-kernel">Customizing the Android Kernel</h5>
<p>Many operations performed by a process, such as allocating memory and accessing files, rely on services provided by the kernel in the form of system calls. In an ARM environment, system calls are done with the SVC instruction which triggers a software interrupt. This interrupt calls the vector_swi() kernel function, which then uses the system call number as an offset into a table of function pointers. In Android, this table is exported with the symbol name sys_call_table.<br />
System call hooking is a commonly used technique to monitor and manipulating the interface between user mode and kernel mode. Hooks can be installed in different ways, but rewriting the function pointers in sys_call_table is probably the easiest and most straight-forward.<br />
Newer stock Android kernels enforce some restrictions that prevent system call hooking. Specifically, the stock Lollipop and Marshmallow kernels for the Nexus 5 are built with the CONFIG_STRICT_MEMORY_RWX option enabled. This prevents writing to kernel code regions read-only data, which means that any attempts to patch kernel code or sys_call_table result in a segmentation fault and reboot. For the purpose of our sandbox however, we can simply build our own kernel that disables this feature.<br />
Given that we have to compile a custom kernel for our sandbox anyway, we’ll also add a couple more features for added convenience, such as LKM support and the /dev/kmem interface.<br />
To build the Android kernel you need a toolchain (set of programs to cross-compile the sources) as well as the appropriate version of the kernel sources. Instructions on how to identify the correct git repository and branch for a given device and Android version can be found at:</p>
<p><a href="https://source.android.com/source/building-kernels.html#id-version" class="uri">https://source.android.com/source/building-kernels.html#id-version</a></p>
<p>For example, to get kernel sources for Lollipop that are compatible with the Nexus 5, we need to clone the msm repo and check out one the android-msm-hammerhead branch (hammerhead is the “codename” of the Nexus 5., and yes, finding the right branch is a confusing process). Once the sources are downloaded, create the default kernel config file with the command make hammerhead_defconfig (or whatever_defconfig, depending on your target device).</p>
<pre><code>$ git clone https://android.googlesource.com/kernel/msm.git
$ cd msm
$ git checkout origin/android-msm-hammerhead-3.4-lollipop-mr1
$ make hammerhead_defconfig
$ vim .config</code></pre>
<p>I recommend using the following settings to enable the most important tracing facilities, add loadable module support, and open up kernel memory for patching.</p>
<pre><code>CONFIG_MODULES=Y
CONFIG_STRICT_MEMORY_RWX=N
CONFIG_DEVMEM=Y
CONFIG_DEVKMEM=Y
CONFIG_KALLSYMS=Y
CONFIG_KALLSYMS_ALL=Y
CONFIG_HAVE_KPROBES=Y
CONFIG_HAVE_KRETPROBES=Y
CONFIG_HAVE_FUNCTION_TRACER=Y
CONFIG_HAVE_FUNCTION_GRAPH_TRACER=Y
CONFIG_TRACING=Y
CONFIG_FTRACE=Y
CONFIG KDB=Y</code></pre>
<p>Once you are finished editing save the .config file and build the kernel.</p>
<pre><code>$ export ARCH=arm
$ export SUBARCH=arm
$ export CROSS_COMPILE=/path_to_your_ndk/arm-eabi-4.8/bin/arm-eabi-
$ make</code></pre>
<p>If the build process completes successfully, you will find the bootable kernel image at arch/arm/boot/zImage-dtb.</p>
<h5 id="booting-the-custom-environment">Booting the Custom Environment</h5>
<p>The fastboot boot command allows you to test your new kernel and ramdisk without actually flashing it (once you’re sure it everything works, you can make the changes permanent with fastboot flash). Restart the device in fastboot mode with the following command:<br />
$ adb reboot bootloader</p>
<p>Then, use the fastboot command to boot Android with the new kernel and ramdisk, passing the boot parameters of the original image:<br />
~~~~<br />
$ fastboot boot zImage-dtb myinitrd.img --base 0 --kernel-offset 0x8000 --ramdisk-offset 0x2900000 --tags-offset 0x2700000 -c &quot;console=ttyHSL0,115200,n8 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1&quot;<br />
~~~~</p>
<p>To quickly verify that the new kernel is running, navigate to Settings-&gt;About phone and check the “kernel version” field.</p>
<h5 id="loading-kernel-modules">Loading Kernel Modules</h5>
<h5 id="example-file-hiding">Example: File Hiding</h5>
<h2 id="tampering-and-reverse-engineering-on-ios">Tampering and Reverse Engineering on iOS</h2>
<h3 id="basics-1">Basics</h3>
<h3 id="environment-and-toolset-1">Environment and Toolset</h3>
<h4 id="xcode-and-ios-sdk">XCode and iOS SDK</h4>
<h4 id="utilities">Utilities</h4>
<p>Class-dump by Steve Nygard is a command-line utility for examining the Objective-C runtime information stored in Mach-O files. It generates declarations for the classes, categories and protocols.</p>
<p><a href="http://stevenygard.com/projects/class-dump/" class="uri">http://stevenygard.com/projects/class-dump/</a></p>
<p>Class-dump-dyld by Elias Limneos allows dumping and retrieving symbols directly from the shared cache, eliminating the need to extract the files first. It can generate header files from app binaries, libraries, frameworks, bundles or the whole dyld_shared_cache. Is is also possible to Mass-dump the whole dyld_shared_cache or directories recursively.</p>
<p><a href="https://github.com/limneos/classdump-dyld/" class="uri">https://github.com/limneos/classdump-dyld/</a></p>
<h3 id="jailbreaking-an-ios-device">Jailbreaking an iOS Device</h3>
<h3 id="manipulating-ios-apps">Manipulating iOS Apps</h3>
<h3 id="hooking-with-mobilesubstrate">Hooking with MobileSubstrate</h3>
<h4 id="example-deactivating-anti-debugging">Example: Deactivating Anti-Debugging</h4>
<pre><code>#import &lt;substrate.h&gt;

#define PT_DENY_ATTACH 31

static int (*_my_ptrace)(int request, pid_t pid, caddr_t addr, int data);


static int $_my_ptrace(int request, pid_t pid, caddr_t addr, int data) {
    if (request == PT_DENY_ATTACH) {
        request = -1;
    }
    return _ptraceHook(request,pid,addr,data);
}

%ctor {
    MSHookFunction((void *)MSFindSymbol(NULL,&quot;_ptrace&quot;), (void *)$ptraceHook, (void **)&amp;_ptraceHook);
}</code></pre>
<h3 id="code-injection">Code Injection</h3>
<h4 id="cynject">Cynject</h4>
<p>Cycript is traditionally used in the iOS world. It also runs standalone on Android, however without injection support. It is based on a Java VM that can be injected into a running process using Cydia Substrate. The user then communicates with process through the Cycript console interface.</p>
<p>Cycript injects a JavaScriptCore VM into the running process. Users can then manipulate the process using JavaScript with some syntax extensions through the Cycript Console.</p>
<p>*(Todo - use cases and example for Cycript)</p>
<ul>
<li>Obtain references to existing objects</li>
<li>Instantiate objects from classes</li>
<li>Hooking native functions</li>
<li>Hooking objective-C methods</li>
<li>etc.*<br />
<a href="http://www.cycript.org/manual/" class="uri">http://www.cycript.org/manual/</a></li>
</ul>
<p>Cycript tricks:</p>
<p><a href="http://iphonedevwiki.net/index.php/Cycript_Tricks" class="uri">http://iphonedevwiki.net/index.php/Cycript_Tricks</a></p>
<h4 id="frida">Frida</h4>
<h5 id="example-bypassing-jailbreak-detection">Example: Bypassing Jailbreak Detection</h5>
<pre><code>import frida
import sys

try:
    session = frida.get_usb_device().attach(&quot;Target Process&quot;)
except frida.ProcessNotFoundError:
    print &quot;Failed to attach to the target process. Did you launch the app?&quot;
    sys.exit(0);

script = session.create_script(&quot;&quot;&quot;

    // Handle fork() based check

  var fork = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;fork&quot;);

    Interceptor.replace(fork, new NativeCallback(function () {
        send(&quot;Intercepted call to fork().&quot;);
        return -1;
    }, &#39;int&#39;, []));

  var system = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;system&quot;);

    Interceptor.replace(system, new NativeCallback(function () {
        send(&quot;Intercepted call to system().&quot;);
        return 0;
    }, &#39;int&#39;, []));

    // Intercept checks for Cydia URL handler

    var canOpenURL = ObjC.classes.UIApplication[&quot;- canOpenURL:&quot;];

    Interceptor.attach(canOpenURL.implementation, {
        onEnter: function(args) {
          var url = ObjC.Object(args[2]);
          send(&quot;[UIApplication canOpenURL:] &quot; + path.toString());
          },
        onLeave: function(retval) {
            send (&quot;canOpenURL returned: &quot; + retval);
        }

    });     

    // Intercept file existence checks via [NSFileManager fileExistsAtPath:]

    var fileExistsAtPath = ObjC.classes.NSFileManager[&quot;- fileExistsAtPath:&quot;];
    var hideFile = 0;

    Interceptor.attach(fileExistsAtPath.implementation, {
        onEnter: function(args) {
          var path = ObjC.Object(args[2]);
          // send(&quot;[NSFileManager fileExistsAtPath:] &quot; + path.toString());

          if (path.toString() == &quot;/Applications/Cydia.app&quot; || path.toString() == &quot;/bin/bash&quot;) {
            hideFile = 1;
          }
        },
        onLeave: function(retval) {
            if (hideFile) {
                send(&quot;Hiding jailbreak file...&quot;);MM
                retval.replace(0);
                hideFile = 0;
            }

            // send(&quot;fileExistsAtPath returned: &quot; + retval);
      }
    });


    /* If the above doesn&#39;t work, you might want to hook low level file APIs as well

        var openat = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;openat&quot;);
        var stat = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;stat&quot;);
        var fopen = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;fopen&quot;);
        var open = Module.findExportByName(&quot;libsystem_c.dylib&quot;, &quot;open&quot;);
        var faccesset = Module.findExportByName(&quot;libsystem_kernel.dylib&quot;, &quot;faccessat&quot;);

    */

&quot;&quot;&quot;)

def on_message(message, data):
    if &#39;payload&#39; in message:
            print(message[&#39;payload&#39;])

script.on(&#39;message&#39;, on_message)
script.load()
sys.stdin.read()</code></pre>
<h3 id="reverse-engineering-on-ios">Reverse Engineering on iOS</h3>
<h4 id="dumping-decrypted-executables">Dumping Decrypted Executables</h4>
<p>For iOS, distributed application package are usually stored in an IPA format which an archive file containing application bundles which contain executable binary, resource files, support files and application properties. But when an application is released to the App Store, application's binary will be encrypted by Apple's FairPlay (DRM). Therefore, to perform a static analysis, a binary of an application need to be decrypted first.</p>
<p>In order to analyze the iOS application from App Store, Tester need to decrypt the application which can be automatically conducted using “dumpdecrypted” tool developed by Stefan Esser.</p>
<p>To use “dumpdecrypted”, connect to the iOS device using SSH and set the DYLD_INSERT_LIBRARIES environment variable when executing the target binary:</p>
<pre><code>ssh root@&lt;ip of idevice&gt;
iPod:root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Example.app/Example</code></pre>
<p>The decrypted binary is saved in the current working directory.</p>
<h4 id="analyzing-swift-apps">Analyzing Swift Apps</h4>
<h3 id="debugging-ios-apps">Debugging iOS Apps</h3>
<p>iOS ships with a console app, debugserver, that allows for remote debugging using gdb or lldb. By default however, debugserver cannot be used to attach to arbitrary processes (it is usually only used for debugging self-developed apps deployed with XCode). To enable debugging of third-part apps, the task_for_pid entitlement must be added to the debugserver executable. An easy way to do t</p>
<p>his is adding the entitlement to the debugserver binary shipped with XCode.</p>
<p>To obtain the executable mount the following DMG image:</p>
<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/ DeviceSupport/&lt;target-iOS-version//DeveloperDiskImage.dmg</code></pre>
<p>You’ll find the debugserver executable in the /usr/bin/ directory on the mounted volume - copy it to a temporary directory. Then, create a file called entitlements.plist with the following content:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/ PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;run-unsigned-code&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;get-task-allow&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;task_for_pid-allow&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre>
<p>And apply the entitlement with codesign:</p>
<pre><code>codesign -s - --entitlements entitlements.plist -f debugserver</code></pre>
<p>Copy the modified binary to any directory on the test device (note: The following examples use usbmuxd to forward a local port through USB).</p>
<pre><code>$ ./tcprelay.py -t 22:2222
$ scp -P2222 debugserver root@localhost:/tmp/</code></pre>
<p>You can now attach debugserver to any process running on the device.</p>
<pre><code>VP-iPhone-18:/tmp root# ./debugserver *:1234 -a 2670
debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-320.2.89
 for armv7.
Attaching to process 2670...</code></pre>
<p>Reference: <a href="http://iphonedevwiki.net/index.php/Debugserver" class="uri">http://iphonedevwiki.net/index.php/Debugserver</a></p>
<h1 id="security-testing-in-the-software-development-lifecycle">Security Testing in the Software Development Lifecycle</h1>
<h1 id="assessing-the-quality-of-software-protections">Assessing the Quality of Software Protections</h1>
<p>This chapter covers defense-in-depth measures that are recommended for apps that process, or give access to, sensitive data or functionality. Lack of any of these controls does not cause a vulnerability - instead, they are meant to increase the app's resiliency against reverse engineering, making it more difficult for adversaries to gain an understanding of the app's internals or extract data from the app.</p>
<h2 id="testing-software-protections">Testing Software Protections</h2>
<p>Whether we’re talking about malware, banking apps, or mobile games: They all use anti-reversing strategies made from the same building blocks. This includes defenses against debuggers, tamper proofing of application files and memory, and verifying the integrity of the environment. The question is, how do we verify that the defenses, taken together, are “good enough” to provide the desired level of protection in a given scenario? In the MASVS and MSTG, we tackle this question by defining sets of criteria for obfuscations and functional (programmatic) defenses, as well as testing processes that can be used for manual verification.</p>
<h3 id="software-protections-model">Software Protections Model</h3>
<p>On the highest level, we classify reverse engineering defenses into two categories: Functional defenses and obfuscations. Both are used in tandem to achieve resiliency. Table 1 gives an overview of the categories and sub-categories as they appear in the guide.</p>
<h4 id="functional-defenses">1. Functional defenses</h4>
<p><em>Functional defenses</em> are program functions that prevent, or react to, actions of the reverse engineer. They can be further categorized into two modi operandi:</p>
<ol>
<li><p>Preventive: Functions that aim to prevent likely actions of the reverse engineer. As an example, an app may an operating system API to prevent debuggers from attaching to the process.</p></li>
<li><p>Reactive: Features that aim to detect, and respond to, tools or actions of the reverse engineer. For example, an app could terminate when it suspects being run in an emulator, or change its behavior in some way a debugger is attached.</p></li>
</ol>
<h4 id="obfuscating-transformations">2. Obfuscating Transformations</h4>
<p><em>Obfuscating transformations</em> are modifications applied during the build process to the source code, binary, intermediate representation of the code, or other elements such as data or executable headers. The goal is to transform the code and data so it becomes more difficult to comprehend for human adversaries while still performing the desired function. Obfuscating transformations are further categorized into two types:</p>
<ol>
<li>Strip information</li>
<li>Obfuscate control flow and data</li>
</ol>
<p>Effective anti-reversing schemes combine a variety of functional defenses and obfuscating transformations. Note that in the majority of cases, applying basic measures such as symbol stripping and root detection is sufficient (MASVS L2). In some cases however it is desirable to increase resiliency against reverse engineering - in these cases, advanced functional defenses and obfuscating transformations may be added (MASVS L3-L4).</p>
<h3 id="functional-defense-requirements">Functional Defense Requirements</h3>
<p>Functional defenses are programmatic features that aim to detect, and respond to, tools or actions of the reverse engineer. For example, an app could terminate when it suspects being run in an emulator, or change its behavior in some way a debugger is attached. When combined with obfuscation, multiple defenses add up to make the life of the reverse engineer as difficult as possible.</p>
<p>In the MASVS and MSTG, we define five defensive categories, each of which corresponds to a process used by reverse engineers (Figure 2). The MASVS defines the minimum amount of protection that must exist in each category.</p>
<p><img src="https://github.com/OWASP/owasp-mstg/blob/master/Document/images/reversing-processes.png" title="Reverse engineering processes" alt="Reverse engineering processes" /></p>
<p>For example, MASVS L2 requires an app to implement a simple form protection in the categories “environmental manipulation” and “debugging”. An app may pass as long as it implements any form of detection, no matter the specific implementation. MASVS L3 ups the ante by adding requirements for all five categories:</p>
<ul>
<li>8.6: &quot;Verify that the app implements two or more functionally independent methods of root detection and responds to the presence of a rooted device either by alerting the user or terminating the app.&quot;</li>
<li>8.7: &quot;Verify that the app implements multiple defenses that result in strong resiliency against debugging. All available means of debugging must be covered (e.g. JDWP and native).&quot;</li>
<li>8.8: &quot;Verify that the app detects and responds to tampering with executable files and critical data.&quot;</li>
<li>8.9: &quot;Verify that the app detects the presence of widely used reverse engineering tools, such as code injection tools, hooking frameworks and debugging servers.&quot;</li>
<li>8.10: &quot;Verify that the app detects whether it is run inside an emulator using any method, and responds by terminating or malfunctioning when an emulator is detected.&quot;</li>
<li>8.11: &quot;Verify that the app detects modifications of process memory, including relocation table patches and injected code.&quot;</li>
</ul>
<p>Basic requirements, such as 8.8 and 8.9, can be verified using either black-box or white-box testing (see the respective test cases for details). The requirement for <em>strong</em> resiliency in the debugging category (V8.7) will be discussed in the following sections.</p>
<h4 id="testing-functional-defenses">Testing Functional Defenses</h4>
<p>The simple, score-based system described below is based practical experience and feedback from malware analysts and reverse engineers. For a given defensive category, each defense in the category is scored individually, and the scores are then added to obtain a final score. A “defense” in this context is a function, or group of functions, with a common modus operandi and goal.</p>
<p>Each individual defensive function is assessed on three properties:</p>
<ul>
<li>Uniqueness: 1 – 3 points</li>
<li>API Layer: Up to 2 bonus points</li>
<li>Parallelism: Up to 2 bonus points</li>
</ul>
<p>Table 2 explains the scoring criteria in detail.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th align="center"><strong>Uniqueness</strong></th>
<th align="right"><strong>API Layer</strong></th>
<th><strong>Parallelism</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Rationale</strong></td>
<td align="center"><em>Lower-level calls are more difficult to defeat than higher level calls.</em></td>
<td align="right"><em>The more original and/or customized the anti-reversing trick, the less likely the adversary has seen it all before</em>.</td>
<td><em>Debugging and disabling a mechanism becomes more difficult when multiple threats or processes are involved.</em></td>
</tr>
<tr class="even">
<td><strong>Level 1</strong></td>
<td align="center">Standard API (1 point): The feature relies on APIs that are specifically meant to hinder reverse engineering. It can be bypassed easily using generic</td>
<td align="right">System Library (1 point): The feature relies on public library functions or methods.</td>
<td>Single thread</td>
</tr>
<tr class="odd">
<td><strong>Level 2</strong></td>
<td align="center">Published (2 points): A well-documented and commonly used technique is used. It can be bypassed by using widely available tools with a moderate amount of customization.</td>
<td align="right">Kernel (1 bonus point): The anti-reversing feature calls directly into the kernel.</td>
<td>N/A</td>
</tr>
<tr class="even">
<td><strong>Level 3</strong></td>
<td align="center">Proprietary (3 points): The feature is not commonly found in published anti-reverse-engineering resources for the target operating system, or a known technique has been sufficiently extended / customized to cause significant effort for the reverse engineer</td>
<td align="right">Self-contained (2 bonus points): The feature does not require any library or system calls to work.</td>
<td>Multiple threads or processes (2 bonus points)</td>
</tr>
</tbody>
</table>
<h3 id="obfuscation-requirements">Obfuscation Requirements</h3>
<h4 id="strip-meaningful-information">1. Strip meaningful information</h4>
<p>Compiled programs often retain explanative information that is helpful for the reverse engineer, but isn’t actually needed for the program to run. Debugging symbols that map machine code or byte code to line numbers, function names and variable names are an obvious example.</p>
<p>For instance, class files generated with the standard Java compiler include the names of classes, methods and fields, making it trivial to reconstruct the source code. ELF and Mach-O binaries have a symbol table that contains debugging information, including the names of functions, global variables and types used in the executable.<br />
Stripping this information makes a compiled program less intelligible while fully preserving its functionality. Possible methods include removing tables with debugging symbols, or renaming functions and variables to random character combinations instead of meaningful names. This process sometimes reduces the size of the compiled program and doesn’t affect its runtime behavior.</p>
<h4 id="obfuscate-control-flow-and-data">2. Obfuscate control flow and data</h4>
<p>Program code and data can be transformed in unlimited ways - and indeed, the field of control flow and data obfuscation is highly diverse, with a large amount of research dedicated to both obfuscation and de-obfuscation. Deriving general rules as to what is considered <em>strong</em> obfuscation is not an easy task. In the MSTG model, we take a two-fold approach:</p>
<ol>
<li>Apply complexity and distance metrics to quantify the overall impact of the obfuscating transformations;</li>
<li>Define domain-specific criteria based on the state-of-the-art in obfuscation research.</li>
</ol>
<p>Our working hypothesis that reverse engineering effort generally increases with program complexity, as long as no well-known automated de-obfuscation techniques exits. Note that it is unrealistic to assume that strong resiliency can be proven in a scientifically sound way for a complex application. Our goal is to provide guidelines, processes and metrics that enable a human tester to provide a reasonable assessment of whether strong resiliency has been achieved. Ideally, experimental data can then be used to verify (or refute) the proposed metrics. The situation is analogue to &quot;regular&quot; security testing: For real-world apps, automated static/dynamic analysis is insufficient to prove security of a program. Manual verification by an experienced tester is still the only reliable way to achieve security.</p>
<p>Different types of obfuscating transformations vary in their impact on program complexity. In general, there is a gradient from simple <em>tricks</em>, such as packing and encryption of large code blocks and manipulations of executable headers, to more &quot;intricate&quot; forms of obfuscation that add significant complexity to parts of the code, data and execution trace.</p>
<p>Simple transformations can be used to defeat standard static analysis tools without causing too much impact on size on performance. The execution trace of the obfuscated function(s) remains more or less unchanged. De-obfuscation is relatively trivial, and can be accomplished with standard tools without scripting or customization.</p>
<p>Advanced methods aim to hide the semantics of a computation by computing the same function in a more complicated way, or encoding code and data in ways that are not easily comprehensible. Transformations in this category have the following properties:</p>
<ul>
<li>The size and performance penalty can be sizable (scales with the obfuscation settings)</li>
<li>De-obfuscation requires advanced methods and/or custom tools</li>
</ul>
<p>A simple example for this kind of obfuscations are opaque predicates. Opaque predicates are redundant code branches added to the program that always execute the same way, which is known a priori to the programmer but not to the analyzer. For example, a statement such as if (1 + 1) = 1 always evaluates to false, and thus always result in a jump to the same location. Opaque predicates can be constructed in ways that make them difficult to identify and remove in static analysis.<br />
Some types of obfuscation that fall into this category are:</p>
<ul>
<li>Pattern-based obfuscation, when instructions are replaced with more complicated instruction sequences</li>
<li>Control flow obfuscation</li>
<li>Control flow flattening</li>
<li>Function Inlining</li>
<li>Data encoding and reordering</li>
<li>Variable splitting</li>
<li>Virtualization</li>
<li>White-box cryptography</li>
</ul>
<h1 id="testing-tools">Testing Tools</h1>
<p>To perform security testing different tools are available in order to be able to manipulate requests and responses, decompile Apps, investigate the behaviour of running Apps and other test cases and automate them.</p>
<h2 id="tools-for-android-and-ios">Tools for Android and iOS:</h2>
<ul>
<li><a href="https://github.com/ajinabraham/Mobile-Security-Framework-MobSF">Mobile Security Framework - MobS</a></li>
<li><a href="https://github.com/iSECPartners/Introspy-Analyzer">Introspy-Analyzer</a></li>
</ul>
<h2 id="tools-for-android">Tools for Android:</h2>
<ul>
<li><a href="https://labs.mwrinfosecurity.com/tools/drozer/">Drozer</a></li>
<li><a href="https://github.com/androguard/androguard">Androguard</a></li>
<li><a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge - adb</a></li>
<li><a href="https://manifestsecurity.com/appie/">Appie - Android Pentesting Portable Integrated Environment</a></li>
</ul>
<h3 id="decompile">Decompile</h3>
<ul>
<li><a href="https://ibotpeaches.github.io/Apktool/">Apktool</a></li>
<li><a href="https://github.com/skylot/jadx">JADX</a></li>
<li><a href="http://jd.benow.ca/">JD-GUI</a></li>
</ul>
<h2 id="ios-2">iOS</h2>
<ul>
<li><a href="https://github.com/mwrlabs/needle">needle</a></li>
<li><a href="http://www.idbtool.com/">idb</a></li>
<li><a href="http://www.i-funbox.com/">iFunBox</a></li>
</ul>
<h2 id="interception-proxies">Interception Proxies</h2>
<ul>
<li><a href="https://portswigger.net/burp/download.html">Burp suite</a></li>
<li><a href="https://github.com/zaproxy/zaproxy">OWASP ZAP</a></li>
<li><a href="http://www.telerik.com/fiddler">Fiddler</a></li>
</ul>
<h2 id="ide">IDE</h2>
<ul>
<li><a href="https://www.jetbrains.com/idea/download/">IntelliJ</a></li>
<li><a href="https://eclipse.org/">Eclipse</a></li>
</ul>
<h1 id="suggested-reading">Suggested Reading</h1>
<h2 id="basic-knowledge">Basic Knowledge</h2>
<h2 id="mobile-app-security">Mobile App Security</h2>
<h3 id="android-2">Android</h3>
<ul>
<li><p>Dominic Chell, Tyrone Erasmus, Shaun Colley, Ollie Whitehous (2015) <em>Mobile Application Hacker's Handbook</em>. Wiley. Available at: <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-1118958500.html" class="uri">http://www.wiley.com/WileyCDA/WileyTitle/productCd-1118958500.html</a></p></li>
<li><p>Joshua J. Drake, Zach Lanier, Collin Mulliner, Pau Oliva, Stephen A. Ridley, Georg Wicherski (2014) <em>Android Hacker's Handbook</em>. Wiley. Available at: <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-111860864X.html" class="uri">http://www.wiley.com/WileyCDA/WileyTitle/productCd-111860864X.html</a></p></li>
</ul>
<h3 id="ios-3">iOS</h3>
<h3 id="misc">Misc</h3>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<ul>
<li><p>Bruce Dang, Alexandre Gazet, Elias Backaalany (2014) <em>Practical Reverse Engineering</em>. Wiley. Available at: <a href="http://as.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html" class="uri">http://as.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html</a></p></li>
<li><p>Skakenunny, Hangcom <em>iOS App Reverse Engineering</em>. Online. Available at: <a href="https://github.com/iosre/iOSAppReverseEngineering/" class="uri">https://github.com/iosre/iOSAppReverseEngineering/</a></p></li>
<li><p>Bernhard Mueller (2016) <em>Hacking Soft Tokens - Advanced Reverse Engineering on Android</em>. HITB GSEC Singapore. Available at:</p></li>
<li><p>Dennis Yurichev (2016) <em>Reverse Engineering for Beginners</em>. Online. Available at: <a href="https://github.com/dennis714/RE-for-beginners" class="uri">https://github.com/dennis714/RE-for-beginners</a></p></li>
</ul>
<h1 id="detailed-guides">Detailed Guides</h1>
<h2 id="overview">Overview</h2>
<h3 id="testing-data-storage">Testing Data Storage</h3>
<h4 id="omtg-datast-001-test-credential-storage">OMTG-DATAST-001: Test Credential Storage</h4>
<p>Mobile operating systems offer different native functions to store sensitive information like credentials and keys encrypted within the device. In case credentials or keys needs to be stored, several best practices available on the OS level should be applied to make it harder for attackers to retrieve these information. The following tasks should be done when analysing an App:</p>
<ul>
<li>Identify keys and passwords in the App, e.g. entered by the users, sent back by the endpoint, shipped within the App and how this sensitive data is processed locally.</li>
<li>Decide with the developers if this sensitive stored information locally is needed and if not, how it can be removed or moved to the server (endpoint).</li>
</ul>
<p>The credo for saving data can be summarized quite easy: Public data should be available for everybody, but sensitive and private data needs to be protected or not stored in the first place on the device itself.<br />
This vulnerability can have many consequences, like disclosure of encryption keys that can be used by an attacker to decrypt information. More generally speaking an attacker might be able to identify these information to use it as a basis for other attacks like social engineering (when PII is disclosed), session hijacking (if session information or a token is disclosed) or gather information from apps that have a payment option in order to attack it.</p>
<p>This vulnerability occurs when sensitive data is not properly protected by an app when persistently storing it. The app might be able to store it in different places, for example locally on the device or on an external SD card. When trying to exploit this kind of issues, consider that there might be a lot of information processed and stored in different locations. It is important to identify at the beginning what kind of information is processed by the mobile application and keyed in by the user and what might be interesting and valuable for an attacker (e.g. passwords, credit card information).</p>
<h4 id="omtg-datast-002-test-for-sensitive-data-disclosure-in-log-files">OMTG-DATAST-002: Test for Sensitive Data Disclosure in Log Files</h4>
<p>There are many legit reasons to create log files on a mobile device, for example to keep track of crashes or errors that are stored locally when being offline and being sent to the application developer/company once online again or for usage statistics. However, logging sensitive data such as credit card number and session IDs might expose the data to attackers or malicious applications.<br />
Log files can be created in various ways on each of the different operating systems. The following list shows the mechanisms that are available on Android:</p>
<table>
<thead>
<tr class="header">
<th align="left">Android</th>
<th align="left">iOS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Log Class, .log[a-Z]</td>
<td align="left">NSLog Method</td>
</tr>
<tr class="even">
<td align="left">Logger Class</td>
<td align="left">printf-like function</td>
</tr>
<tr class="odd">
<td align="left">StrictMode</td>
<td align="left">NSAssert-like function</td>
</tr>
<tr class="even">
<td align="left">System.out/System.err.print</td>
<td align="left">Macro</td>
</tr>
</tbody>
</table>
<p>Classification of sensitive information can vary between different industries, countries and their laws and regulations. Therefore laws and regulations need to be known that are applicable to it and to be aware of what sensitive information actually is in the context of the App.</p>
<h4 id="omtg-datast-003-test-for-sensitive-information-in-cloud-storage">OMTG-DATAST-003: Test for Sensitive Information in Cloud Storage</h4>
<p>Android provides two ways for apps to backup their data to the cloud:</p>
<ul>
<li>Auto Backup for Apps (available &gt;= API level 23), which uploads the data to the users Google Drive account.</li>
<li>Key/Value Backup (Backup API), which uploads the data to the Anrdoid Backup Service.</li>
</ul>
<h4 id="omtg-datast-004-test-data-communication-with-third-parties">OMTG-DATAST-004: Test Data Communication with Third Parties</h4>
<p>Different 3rd party services are available that can be embedded into the App to implement different features. This features can vary from tracker services to monitor the user behaviour within the App, selling banner advertisements or to create a better user experience. Interacting with these services abstracts the complexity and neediness to implement the functionality on it’s own and to reinvent the wheel.<br />
The downside is that a developer doesn’t know in detail what code is executed via 3rd party libraries and therefore giving up visibility. Consequently it should be ensured that not more information as needed is sent to the service and that no sensitive information is disclosed.<br />
3rd party services are mostly implemented in two ways:</p>
<ul>
<li>By using a standalone library, like a Jar in an Android project that is getting included into the APK.</li>
<li>By using a full SDK.</li>
</ul>
<h4 id="omtg-datast-005-test-for-sensitive-data-in-the-keyboard-cache">OMTG-DATAST-005: Test for Sensitive Data in the Keyboard Cache</h4>
<p>When keying in data into input fields, the software keyboard automatically suggests what data the user might want to key in. This feature can be very useful in messaging Apps to write text messages more efficient. For input fields that are asking for sensitive information like passwords or credit card data the keyboard cache might disclose sensitive information already when the input field is selected. This feature should therefore be disabled for input fields that are asking for sensitive information.</p>
<h4 id="omtg-datast-006-test-for-sensitive-data-in-the-clipboard">OMTG-DATAST-006: Test for Sensitive Data in the Clipboard</h4>
<p>[General description]</p>
<h4 id="omtg-datast-007-test-for-sensitive-data-leakage-via-ipc-mechanisms">OMTG-DATAST-007: Test for Sensitive Data Leakage via IPC Mechanisms</h4>
<p>During development of mobile application, traditional techniques for IPC might be applied like usage of shared files or network sockets. As mobile application platforms implement their own system functionality for IPC these mechanisms should be applied as they are much more mature than traditional techniques. Using IPC mechanisms with no security in mind may cause the application to leak or expose sensitive data.</p>
<h4 id="omtg-datast-008-test-for-sensitive-data-in-the-user-interface-and-screenshots">OMTG-DATAST-008: Test for Sensitive Data in the User Interface and Screenshots</h4>
<p>Sensitive data could be exposed if a user deliberately takes a screenshot of the application (containing sensitive data), or in the case of malicious application running on the device, that is able to continuously capture the screen. For example, capturing a screenshot of a bank application running on the device may reveal information about the user account, his credit, transactions and so on.</p>
<h4 id="omtg-datast-009-test-for-sensitive-data-in-backups">OMTG-DATAST-009: Test for Sensitive Data in Backups</h4>
<p>When backup options are available, it is important to consider that user data may be stored within application configuration data. This feature could potentially leak sensitive information such as sessions, usernames, emails, passwords, keys and much more.<br />
Consider to encrypt backup data and avoid to store any sensitive information that is not strictly required.</p>
<h4 id="omtg-datast-010-test-for-sensitive-data-in-the-backgrounded-app">OMTG-DATAST-010: Test for Sensitive Data in the Backgrounded App</h4>
<p>Manufacturers want to provide device users an aesthetically pleasing effect when an application is entered or exited, hence they introduced the concept of saving a screenshot when the application goes into the background. This feature could potentially pose a security risk for an application, as the screenshot containing sensitive information (e.g. a screenshot of an email or corporate documents) is written to local storage, where it is recovered either by a rogue application on a jailbroken device, or by someone who steals the device.</p>
<h4 id="omtg-datast-011-test-for-sensitive-data-disclosure-in-process-memory">OMTG-DATAST-011: Test for Sensitive Data Disclosure in Process Memory</h4>
<p>Analyzing the memory can help to identify the root cause of different problems, like for example why an application is crashing, but can also be used to identify sensitive data. This section describes how to check for sensitive data and disclosure of data in general within the process memory.</p>
<p>To be able to investigate the memory of an application a memory dump needs to be created first or the memory needs to be viewed with real-time updates. This is also already the problem, as the application only stores certain information in memory if certain functions are triggered within the application. Memory investigation can of course be executed randomly in every stage of the application, but it is much more beneficial to understand first what the mobile application is doing and what kind of functionalities it offers and also make a deep dive into the decompiled code before making any memory analysis.<br />
Once sensitive functions are identified (like decryption of data) the investigation of a memory dump might be beneficial in order to identify sensitive data like a key or decrypted information.</p>
<h4 id="omtg-datast-012-test-remote-locking-and-wiping">OMTG-DATAST-012: Test Remote Locking and Wiping</h4>
<p>[General description]</p>
<h4 id="omtg-datast-013-test-enforcement-of-device-access-security-policy">OMTG-DATAST-013: Test Enforcement of Device-Access-Security Policy</h4>
<p>[General description]</p>
<h3 id="testing-cryptography">Testing Cryptography</h3>
<h3 id="testing-authentication-and-session-management">Testing Authentication and Session Management</h3>
<h3 id="testing-network-communication">Testing Network Communication</h3>
<h4 id="omtg-net-004-testing-ssl-pinning">OMTG-NET-004: Testing SSL Pinning</h4>
<p>Certificate pinning allows to hard-code in the client the certificate that is known to be used by the server. This technique is used to reduce the threat of a rogue CA and CA compromise. Pinning the server’s certificate take the CA out of games. Mobile applications that implements certificate pinning only have to connect to a limited numbers of server, so a small list of trusted CA can be hard-coded in the application.</p>
<h3 id="testing-environmental-interaction">Testing Environmental Interaction</h3>
<h3 id="testing-code-quality-and-build-settings">Testing Code Quality and Build Settings</h3>
<h3 id="testing-resiliency-against-reverse-engineering">Testing Resiliency against Reverse Engineering</h3>
<h4 id="omtg-rare-001-test-the-custom-keyboard">OMTG-RARE-001: Test the Custom Keyboard</h4>
<h4 id="omtg-rare-002-test-for-sensitive-data-in-ui-components">OMTG-RARE-002: Test for Sensitive Data in UI Components</h4>
<h4 id="omtg-rare-003-test-advanced-jailbreak-root-detection">OMTG-RARE-003: Test Advanced Jailbreak / Root Detection</h4>
<h4 id="omtg-rare-004-test-advanced-debugging-defenses">OMTG-RARE-004: Test Advanced Debugging Defenses</h4>
<h4 id="omtg-rare-005-test-file-tampering-detection">OMTG-RARE-005: Test File Tampering Detection</h4>
<h4 id="omtg-rare-006-test-detection-of-reverse-engineering-tools">OMTG-RARE-006: Test Detection of Reverse Engineering Tools</h4>
<h4 id="omtg-rare-007-test-basic-emulator-detection">OMTG-RARE-007: Test Basic Emulator Detection</h4>
<h4 id="omtg-rare-008-test-memory-tampering-detection">OMTG-RARE-008: Test Memory Tampering Detection</h4>
<h4 id="omtg-rare-009-test-variability-of-tampering-responses">OMTG-RARE-009: Test Variability of Tampering Responses</h4>
<h4 id="omtg-rare-010-test-binary-encryption">OMTG-RARE-010: Test Binary Encryption</h4>
<h4 id="omtg-rare-011-verify-that-defenses-are-well-integrated">OMTG-RARE-011: Verify that Defenses are Well-Integrated</h4>
<h4 id="omtg-rare-012-test-device-binding">OMTG-RARE-012: Test Device Binding</h4>
<h4 id="omtg-rare-013-test-advanced-emulator-detection">OMTG-RARE-013: Test Advanced Emulator Detection</h4>
<h4 id="omtg-rare-013-014-test-advanced-obfuscation">OMTG-RARE-013-014: Test Advanced Obfuscation</h4>
<h2 id="android-3">Android</h2>
<h3 id="omtg-datast-001-1-test-credential-storage"><a name="OMTG-DATAST-001-1"></a>OMTG-DATAST-001-1: Test Credential Storage</h3>
<h4 id="overview-1">Overview</h4>
<p>Mobile operating systems offer different native functions to store sensitive information like credentials and keys encrypted within the device. In case credentials or keys needs to be stored, several best practices available on the OS level should be applied to make it harder for attackers to retrieve these information. The following tasks should be done when analysing an App:</p>
<ul>
<li>Identify keys and passwords in the App, e.g. entered by the users, sent back by the endpoint, shipped within the App and how this sensitive data is processed locally.</li>
<li>Decide with the developers if this sensitive stored information locally is needed and if not, how it can be removed or moved to the server (endpoint).</li>
</ul>
<p>The credo for saving data can be summarized quite easy: Public data should be available for everybody, but sensitive and private data needs to be protected or not stored in the first place on the device itself.<br />
This vulnerability can have many consequences, like disclosure of encryption keys that can be used by an attacker to decrypt information. More generally speaking an attacker might be able to identify these information to use it as a basis for other attacks like social engineering (when PII is disclosed), session hijacking (if session information or a token is disclosed) or gather information from apps that have a payment option in order to attack it.</p>
<p>This vulnerability occurs when sensitive data is not properly protected by an app when persistently storing it. The app might be able to store it in different places, for example locally on the device or on an external SD card. When trying to exploit this kind of issues, consider that there might be a lot of information processed and stored in different locations. It is important to identify at the beginning what kind of information is processed by the mobile application and keyed in by the user and what might be interesting and valuable for an attacker (e.g. passwords, credit card information).</p>
<h4 id="white-box-testing-3">White-box Testing</h4>
<p>Encryption operations should rely on solid and tested functions provided by the SDK. The following describes different “bad practices” that should be checked withi the source code:</p>
<ul>
<li>Check if simple bit operations are used, like XOR or Bit flipping to “encrypt” sensitive information like credentials or private keys that are stored locally. This should be avoided as the data can easily be recovered.</li>
<li>Check if keys are created or used without taking advantage of the Android onboard features like the <a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">KeyStore</a>.</li>
<li>Identify what kind of information is stored persistently and if credentials or keys are disclosed.</li>
</ul>
<p>When going through the source code it should be analyzed if native mechanisms that are offered by Android are applied to the identified sensitive information. Sensitive information should not be stored in clear text and should be encrypted. If sensitive information needs to be stored on the device itself, several functions/API calls are available to protect the data on the Android device by using the <strong>KeyChain</strong> and <strong>Keystore</strong>. The following controls should therefore be used:</p>
<ul>
<li>Check if a key pair is created within the App by looking for the class <code>KeyPairGenerator</code>.</li>
<li>Check that the application is using the KeyStore and Cipher mechanisms to securely store encrypted information on the device. Look for the pattern <code>import java.security.KeyStore</code>, <code>import javax.crypto.Cipher</code>, <code>import java.security.SecureRandom</code> and it’s usage.</li>
<li>The <code>store(OutputStream stream, char[] password)</code> function can be used to store the KeyStore to disk with a specified password. Check that the password provided is not hardcoded and is defined by user input as this should only be known to the user. Look for the pattern <code>.store(</code>.</li>
</ul>
<p>The code should also be analysed if sensitive data is used properly and securely:</p>
<ul>
<li>Sensitive information should not be stored for too long in the RAM (see also <a href="#OMTG-DATAST-011">OMTG-DATAST-011 - Testing for Sensitive Data Disclosure in Process Memory</a>).</li>
<li>Set variables that use sensitive information to null once finished.</li>
<li>Use immutable objects for sensitive data so it cannot be changed.</li>
</ul>
<h4 id="black-box-testing-3">Black-box Testing</h4>
<p>When targetting compiled Android applications, the best way to proceed is to first decompile them in order to obtain something close to the source code (<em><strong>see Decompiling Android App Guide - #TODO-Create a general guide that can bee referenced anywhere in the OMSTF</strong></em>). With the code in your hands you should then be able to inspect and verify if system credentials storage facilities are in place.</p>
<h4 id="remediation">Remediation</h4>
<p>If sensitive information (credentials, keys, PII, etc.) is needed locally on the device several best practices are offered by Android that should be used to store data securely instead of reinventing the wheel or leave it unencrypted on the device.</p>
<p>The following is a list of best practice used for secure storage of certificates and keys and sensitve data in general:</p>
<ul>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android KeyStore</a>: The KeyStore provides a secure system level credential storage. It is important to note that the credentials are not actually stored within the KeyStore. An app can create a new private/public key pair to encrypt application secrets by using the public key and decrypt the same by using the private key. The KeyStores is a secure container that makes it difficult for an attacker to retrieve the private key and guards the encrypted data. Nevertheless an attacker can access all keys on a rooted device in the folder <code>/data/misc/keystore/</code>. The Keystore is encrypted using the user’s own lockscreen pin/password, hence, when the device screen is locked the Keystore is unavailable. More information can be found here: <a href="http://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/" title="Use Android Keystore">how to use Android Keystore</a>.</li>
<li><a href="http://developer.android.com/reference/android/security/KeyChain.html" title="Android KeyChain">Android KeyChain</a>: The KeyChain class is used to store and retrieve private keys and their corresponding certificate (chain). The user will be prompted to set a lock screen PIN or password to protect the credential storage if it hasn’t been set, if something gets imported into the KeyChain the first time.</li>
<li>Encryption or decryption functions that were self implemented need to be avoided. Instead use Android implementations such as <a href="https://developer.android.com/reference/javax/crypto/Cipher.html" title="Cipher">Cipher</a>, <a href="https://developer.android.com/reference/java/security/SecureRandom.html" title="SecureRandom">SecureRandom</a> and <a href="https://developer.android.com/reference/javax/crypto/KeyGenerator.html" title="KeyGenerator">KeyGenerator</a>.<br />
</li>
<li>Username and password should not be stored on the device. Instead, perform initial authentication using the username and password supplied by the user, and then use a short-lived, service-specific authorization token (session token). If possible, use the <a href="https://developer.android.com/reference/android/accounts/AccountManager.html" title="AccountManager">AccountManager</a> class to invoke a cloud-based service and do not store passwords on the device.</li>
<li>As a security in depth measure code obfuscation should also be applied to the App, to make reverse engineering harder for attackers.</li>
</ul>
<h4 id="references-2">References</h4>
<ul>
<li><a href="http://www.androidauthority.com/use-android-keystore-store-passwords-sensitive-information-623779/" title="Use Android Keystore">How to use the Android Keystore to store passwords and other sensitive information</a></li>
<li><a href="http://developer.android.com/reference/android/security/KeyChain.html" title="Android KeyChain">Android KeyChain</a></li>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android KeyStore</a></li>
</ul>
<h5 id="owasp-masvs">OWASP MASVS</h5>
<ul>
<li>V2.1: &quot;System credential storage facilities are used appropriately to store sensitive data, such as user credentials or cryptographic keys.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe">CWE</h5>
<ul>
<li>CWE-311 - Missing Encryption of Sensitive Data</li>
<li>CWE-312 - Cleartext Storage of Sensitive Information</li>
<li>CWE-522 - Insufficiently Protected Credentials</li>
<li>CWE-922 - Insecure Storage of Sensitive Information</li>
</ul>
<h3 id="omtg-datast-001-2-test-for-sensitive-data-disclosure-in-local-storage"><a name="OMTG-DATAST-001-2"></a>OMTG-DATAST-001-2: Test for Sensitive Data Disclosure in Local Storage</h3>
<h4 id="overview-2">Overview</h4>
<p><a href="http://developer.android.com/training/articles/security-tips.html#StoringData" title="StoringData">Storing data</a> is essential for many mobile applications, for example in order to keep track of user settings or data a user might has keyed in that needs to stored locally or offline. Data can be stored persistently by a mobile application in various ways on each of the different operating systems. The following table shows those mechanisms that are available on the Android platform:</p>
<ul>
<li>Shared Preferences</li>
<li>Internal Storage<br />
</li>
<li>External Storage<br />
</li>
<li>SQLite Databases</li>
</ul>
<p>The following examples shows snippets of code to demonstrate bad practices that discloses sensitive information and also shows the different mechanisms in Android to store data.</p>
<p>The following examples shows snippets of code to demonstrate bad practices that discloses sensitive information and also shows the different mechanisms in Android to store data.</p>
<h5 id="shared-preferences">Shared Preferences</h5>
<p><a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">SharedPreferences</a> is a common approach to store Key/Value pairs persistently in the filesystem by using a XML structure. Within an Activity the following code might be used to store sensitive information like a username and a password:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SharedPreferences sharedPref = <span class="fu">getSharedPreferences</span>(<span class="st">&quot;key&quot;</span>, MODE_WORLD_READABLE);
SharedPreferences.<span class="fu">Editor</span> editor = sharedPref.<span class="fu">edit</span>();
editor.<span class="fu">putString</span>(<span class="st">&quot;username&quot;</span>, <span class="st">&quot;administrator&quot;</span>);
editor.<span class="fu">putString</span>(<span class="st">&quot;password&quot;</span>, <span class="st">&quot;supersecret&quot;</span>);
editor.<span class="fu">commit</span>();</code></pre></div>
<blockquote>
<p>Please note that <code>MODE_WORLD_READABLE</code> and <code>MODE_WORLD_WRITEABLE</code> were deprecated in API 17. Although this may not affect newer devices, applications compiled with android:targetSdkVersion set prior to 17 may still be affected, if they run on OS prior to Android 4.2 (<code>JELLY_BEAN_MR1</code>).</p>
</blockquote>
<p>Once the activity is called, the file key.xml is created with the provided data. This code is violating several best practices.</p>
<ul>
<li>The username and password is stored in clear text in <code>/data/data/&lt;PackageName&gt;/shared_prefs/key.xml</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; <span class="kw">?&gt;</span>
<span class="kw">&lt;map&gt;</span>
  <span class="kw">&lt;string</span><span class="ot"> name=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>administrator<span class="kw">&lt;/string&gt;</span>
  <span class="kw">&lt;string</span><span class="ot"> name=</span><span class="st">&quot;password&quot;</span><span class="kw">&gt;</span>supersecret<span class="kw">&lt;/string&gt;</span>
<span class="kw">&lt;/map&gt;</span></code></pre></div>
<ul>
<li><code>MODE_WORLD_READABLE</code> allows all applications to access and read the content of <code>key.xml</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">root@hermes</span>:/data/data/sg.vp.owasp_mobile.myfirstapp/shared_prefs <span class="co"># ls -la</span>
<span class="kw">-rw-rw-r--</span> u0_a118 u0_a118    170 2016-04-23 16:51 key.xml</code></pre></div>
<h5 id="sqlite-databases-unencrypted">SQLite Databases (Unencrypted)</h5>
<p>SQLite is a SQL database that stores data to a text file. The Android SDK comes with built in classes to operate SQLite databases. The main package to manage the databases is android.database.sqlite.<br />
Within an Activity the following code might be used to store sensitive information like a username and a password:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SQLiteDatabase notSoSecure = <span class="fu">openOrCreateDatabase</span>(<span class="st">&quot;privateNotSoSecure&quot;</span>,MODE_PRIVATE,<span class="kw">null</span>);
notSoSecure.<span class="fu">execSQL</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,Password VARCHAR);&quot;</span>);
notSoSecure.<span class="fu">execSQL</span>(<span class="st">&quot;INSERT INTO Accounts VALUES(&#39;admin&#39;,&#39;AdminPass&#39;);&quot;</span>);
notSoSecure.<span class="fu">close</span>();</code></pre></div>
<p>Once the activity is called, the database file <code>privateNotSoSecure</code> is created with the provided data and the data is stored in clear text in <code>/data/data/&lt;PackageName&gt;/databases/privateNotSoSecure</code>.</p>
<p>There might be several files available in the databases directory, besides the SQLite database.</p>
<ul>
<li>Journal files: These are temporary files used to implement atomic commit and rollback capabilities in SQLite (see also <a href="https://www.sqlite.org/tempfiles.html" title="Journal files">tempfiles</a> ).</li>
<li>Lock files: The lock files are part of the locking and journaling mechanism designed to improve concurrency in SQLite and to reduce the writer starvation problem. You can read more here: <a href="https://www.sqlite.org/lockingv3.html" title="Lock Files">lockingv3</a>.</li>
</ul>
<p>Unencrypted SQLite databases should not be used to store sensitive information.</p>
<h5 id="sqlite-databases-encrypted">SQLite Databases (Encrypted)</h5>
<p>By using the library <a href="https://www.zetetic.net/sqlcipher/sqlcipher-for-android/" title="SQLCipher">SQLCipher</a> SQLite databases can be encrypted, by providing a password.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">SQLiteDatabase secureDB = SQLiteDatabase.<span class="fu">openOrCreateDatabase</span>(database, <span class="st">&quot;password123&quot;</span>, <span class="kw">null</span>);
secureDB.<span class="fu">execSQL</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,Password VARCHAR);&quot;</span>);
secureDB.<span class="fu">execSQL</span>(<span class="st">&quot;INSERT INTO Accounts VALUES(&#39;admin&#39;,&#39;AdminPassEnc&#39;);&quot;</span>);
secureDB.<span class="fu">close</span>();</code></pre></div>
<p>If encrypted SQLite databases are used, check if the password is hardcoded in the source, stored in shared preferences or hidden somewhere else in the code or file system.<br />
A secure approach to retrieve the key, instead of storing it locally could be to either:</p>
<ul>
<li>Ask the user every time for a PIN or password to decrypt the database, once the App is opened (weak password or PIN is prone to Brute Force Attacks)</li>
<li>Store the key on the server and make it accessible via a Web Service (then the App can only be used when the device is online)</li>
</ul>
<h5 id="internal-storage">Internal Storage</h5>
<p>Files can be saved directly on the device's <a href="http://developer.android.com/guide/topics/data/data-storage.html#filesInternal" title="UsingInternalStorage">internal storage</a>. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.<br />
Within an Activity the following code might be used to store sensitive information in the variable string persistently to the internal storage:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">FileOutputStream fos = <span class="kw">null</span>;
<span class="kw">try</span> {
   fos = <span class="fu">openFileOutput</span>(FILENAME, Context.<span class="fu">MODE_PRIVATE</span>);
   fos.<span class="fu">write</span>(string.<span class="fu">getBytes</span>());
   fos.<span class="fu">close</span>();
} <span class="kw">catch</span> (FileNotFoundException e) {
   e.<span class="fu">printStackTrace</span>();
} <span class="kw">catch</span> (IOException e) {
   e.<span class="fu">printStackTrace</span>();
}</code></pre></div>
<p>The file mode need to be checked, to make sure that only the app itself has access to the file by using <code>MODE_PRIVATE</code>. Other modes like <code>MODE_WORLD_READABLE</code> (deprecated) and <code>MODE_WORLD_WRITEABLE</code> (deprecated) are more lax and can pose a security risk.</p>
<p>It should also be checked what files are read within the App by searching for the usage of class <code>FileInputStream</code>. Part of the internal storage mechanisms is also the cache storage. To cache data temporarily, functions like <code>getCacheDir()</code> can be used.</p>
<h5 id="external-storage">External Storage</h5>
<p>Every Android-compatible device supports a shared &quot;<a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal" title="UsingExternalStorage">external storage</a>&quot; that you can use to save files. This can be a removable storage media (such as an SD card) or an internal (non-removable) storage.<br />
Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer.<br />
Within an Activity the following code might be used to store sensitive information in the variable string persistently to the external storage:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">File file = <span class="kw">new</span> File (Environment.<span class="fu">getExternalFilesDir</span>(), <span class="st">&quot;password.txt&quot;</span>);
String password = <span class="st">&quot;SecretPassword&quot;</span>;
FileOutputStream fos;
    fos = <span class="kw">new</span> FileOutputStream(file);
    fos.<span class="fu">write</span>(password.<span class="fu">getBytes</span>());
    fos.<span class="fu">close</span>();</code></pre></div>
<p>Once the activity is called, the file is created with the provided data and the data is stored in clear text in the external storage.</p>
<p>It’s also worth to know that files stored outside the application folder (internal: <code>data/data/com.appname/files</code> or external: <code>/storage/emulated/0/Android/data/com.appname/files/</code>) will not be deleted when the user uninstall the application.</p>
<h4 id="white-box-testing-4">White-box Testing</h4>
<p>As already pointed out, there are several ways to store information within Android. Several checks should therefore be applied to the source code of an Android App, once decompiled.</p>
<ul>
<li>Check <code>AndroidManifest.xml</code> for permissions to read and write to external storage, like <code>uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</code></li>
<li>Check the source code for functions and API calls that are used for storing data:</li>
<li>Import the decompiled Java Files in an IDE of your choice (IntelliJ or Eclipse) or use grep on the command line to search for
<ul>
<li>file permissions like:</li>
<li><code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITABLE</code>. IPC files should not be created with permissions of <code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITABLE</code> unless it is required as any app would be able to read or write the file even though it may be stored in the app’s private data directory.</li>
<li>Classes and functions like:</li>
<li>Shared Preferences (Storage of key-value pairs)</li>
<li><code>FileOutPutStream</code> (Using Internal or External Storage)</li>
<li><code>getExternal*</code> functions (Using External Storage)</li>
<li><code>getWritableDatabase</code> function (return a SQLiteDatabase for writing)</li>
<li><code>getReadableDatabase</code> function (return a SQLiteDatabase for reading)</li>
<li><code>getCacheDir</code> and <code>getExternalCacheDirs</code> function (Using cached files)</li>
</ul></li>
</ul>
<h4 id="black-box-testing-4">Black-box Testing</h4>
<p>Install and use the App as it is intended. Afterwards check the following items:</p>
<ul>
<li>Check the files that are shipped with the mobile application once installed in /data/data/<AppName>/files in order to identify development, backup or simply old files that shouldn’t be in a production release.</li>
<li>Check if .db files are available, which are SQLite databases and if they contain sensitive information (usernames, passwords, keys etc.). SQlite databases can be accessed on the command line with sqlite3.</li>
<li>Check Shared Preferences that are stored as XML files in the shared_prefs directory of the App for sensitive information.</li>
<li>Check the file system permissions of the files in /data/data/<app name>. The permission should only allow rwx to the user and his group that was created for the app (e.g. u0_a82) but not to others. Others should have no permissions to files, but may have the executable flag to directories.</li>
</ul>
<h4 id="remediation-1">Remediation</h4>
<p>Usage of <code>MODE_WORLD_WRITEABLE</code> or <code>MODE_WORLD_READABLE</code> should generally be avoided for files. If data needs to be shared with other applications, a content provider should be considered. A content provider offers read and write permissions to other apps and can make dynamic permission grants on a case-by-case basis.</p>
<p>The usage of Shared Preferences or other mechanisms that are not able to protect data should be avoided to store sensitive information. SharedPreferences are insecure and not encrypted by default.</p>
<p>Do not use the external storage for sensitive data. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed.</p>
<p>To provide additional protection for sensitive data, you might choose to encrypt local files using a key that is not directly accessible to the application. For example, a key can be placed in a <a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">KeyStore</a> and protected with a user password that is not stored on the device. While this does not protect data from a root compromise that can monitor the user inputting the password, it can provide protection for a lost device without file system encryption.</p>
<p><a href="https://github.com/scottyab/secure-preferences" title="SecurePreferences">“Secure-preferences</a>” can be used to encrypt the values stored within <a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">Shared Preferences</a>.</p>
<h4 id="references-3">References</h4>
<h5 id="owasp-masvs-1">OWASP MASVS</h5>
<ul>
<li>V2.1: &quot;System credential storage facilities are used appropriately to store sensitive data, such as user credentials or cryptographic keys.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-1">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-1">CWE</h5>
<ul>
<li>CWE-311 - Missing Encryption of Sensitive Data</li>
<li>CWE-312 - Cleartext Storage of Sensitive Information</li>
<li>CWE-522 - Insufficiently Protected Credentials</li>
<li>CWE-922 - Insecure Storage of Sensitive Information</li>
</ul>
<h5 id="info">Info</h5>
<ul>
<li><a href="http://developer.android.com/guide/topics/data/data-storage.html#filesInternal" title="UsingInternalStorage">Internal Storage</a></li>
<li><a href="https://developer.android.com/guide/topics/data/data-storage.html#filesExternal" title="UsingExternalStorage">External Storage</a></li>
<li><a href="http://developer.android.com/training/articles/security-tips.html#StoringData" title="StoringData">Storing Data</a></li>
<li><a href="http://developer.android.com/reference/android/content/SharedPreferences.html" title="SharedPreferences">Shared Preferences</a></li>
<li><a href="https://www.zetetic.net/sqlcipher/sqlcipher-for-android/" title="SQLCipher">SQLCipher</a></li>
<li><a href="https://github.com/scottyab/secure-preferences" title="SecurePreferences">SecurePreferences</a></li>
<li><a href="http://developer.android.com/training/articles/keystore.html" title="Android KeyStore System">Android Keystore</a></li>
<li><a href="https://developer.android.com/training/basics/data-storage/index.html" title="AndroidStorage">Android Storage Documentation</a></li>
</ul>
<h5 id="tools">Tools</h5>
<ul>
<li><a href="https://github.com/google/enjarify" title="Enjarify">Enjarify</a></li>
<li><a href="https://github.com/skylot/jadx" title="JADX">JADX</a></li>
<li><a href="https://github.com/pxb1988/dex2jar" title="Dex2jar">Dex2jar</a></li>
<li><a href="http://developer.android.com/tools/help/lint.html" title="Lint">Lint</a></li>
<li><a href="http://www.sqlite.org/cli.html" title="Sqlite3">SQLite3</a></li>
</ul>
<h3 id="omtg-datast-002-testing-for-sensitive-data-disclosure-in-log-files"><a name="OMTG-DATAST-002"></a>OMTG-DATAST-002: Testing for Sensitive Data Disclosure in Log Files</h3>
<h4 id="overview-3">Overview</h4>
<p>There are many legit reasons to create log files on a mobile device, for example to keep track of crashes or errors that are stored locally when being offline and being sent to the application developer/company once online again or for usage statistics. However, logging sensitive data such as credit card number and session IDs might expose the data to attackers or malicious applications.<br />
Log files can be created in various ways on each of the different operating systems. The following list shows the mechanisms that are available on Android:</p>
<ul>
<li>Log Class, .log[a-Z]</li>
<li>Logger Class<br />
</li>
<li>StrictMode<br />
</li>
<li>System.out/System.err.print</li>
</ul>
<p>Classification of sensitive information can vary between different industries, countries and their laws and regulations. Therefore laws and regulations need to be known that are applicable to it and to be aware of what sensitive information actually is in the context of the App.</p>
<h4 id="white-box-testing-5">White-box Testing</h4>
<p>Check the source code for usage of Logging functions, by searching for the following terms:</p>
<ol>
<li>Function names like:</li>
</ol>
<ul>
<li><code>Log.d</code>, <code>Log.e</code>, <code>Log.i</code>, <code>Log.v</code>, <code>Log.w</code> and so on</li>
<li><code>Logger</code></li>
<li><code>StrictMode</code></li>
</ul>
<ol>
<li>Keywords and system output to identify non-standard log mechanisms like :</li>
</ol>
<ul>
<li>Logfile</li>
<li>logging</li>
<li><code>System.out.print</code> | <code>System.out.println</code></li>
</ul>
<h4 id="black-box-testing-5">Black-box Testing</h4>
<p>Use the mobile app extensively so that all functionality is at least triggered once.</p>
<ol>
<li>Identify the data directory of the application in order to look for log files (<code>/data/data/package_name</code>). Check if log data is generated by checking the application logs, as some mobile applications create and store their own logs in the data directory.<br />
</li>
<li>Many application developers use still <code>System.out.println()</code> or <code>printStackTrace()</code> instead of a proper logging class. Therefore the testing approach also needs to cover all output generated by the application during starting, running and closing of it and not only the output created by the log classes. In order to verify what data is written to <code>logfiles</code> and printed directly by using <code>System.out.println()</code> or <code>printStackTrace()</code> the code should be checked for these functions and the tool <a href="http://developer.android.com/tools/help/logcat.html" title="LogCat"><em>LogCat</em></a> can be used to check the output. Two different approaches are available to execute LogCat.</li>
</ol>
<ul>
<li>LogCat is already part of <em>Dalvik Debug Monitor Server</em> (DDMS) and is therefore built into Android Studio. Once the app is running and in debug mode, patterns can be defined in LogCat to reduce the log output of the app.</li>
</ul>
<p><img src="http://bb-conservation.de/sven/adb.png" alt="Log output in Android Studio" /></p>
<ul>
<li>LogCat can be executed by using adb in order to store the log output permanently.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># adb logcat &gt; logcat.log</span></code></pre></div>
<h4 id="remediation-2">Remediation</h4>
<p>Ensure logging statements are removed from the production release, as logs may be interrogated or readable by other applications. Tools like <strong><a href="http://proguard.sourceforge.net/" title="ProGuard">ProGuard</a></strong>, which is already included in Android Studio or <strong><a href="https://www.guardsquare.com/dexguard" title="DexGuard">DexGuard</a></strong> can be used to strip out logging portions in the code when preparing the production release. For example, to remove logging calls within an android application, simply add the following option in the <em>proguard-project.txt</em> configuration file of Proguard:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">-assumenosideeffects <span class="kw">class</span> android.<span class="fu">util</span>.<span class="fu">Log</span>
{
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">isLoggable</span>(java.<span class="fu">lang</span>.<span class="fu">String</span>, <span class="dt">int</span>);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">v</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">i</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">w</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">d</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">e</span>(...);
<span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">wtf</span>(...);
}</code></pre></div>
<p>Although the <code>android:debuggable=&quot;&quot;</code> flag can be bypassed by repacking the application, before shipping it, it is important to set the option <code>android:debuggable=&quot;false&quot;</code> in the <em>AndroidManifest.xml</em>.</p>
<h4 id="references-4">References</h4>
<h5 id="info-1">Info</h5>
<ul>
<li><a href="http://developer.android.com/reference/android/util/Log.html" title="ClassLogOverview">Overview of Class Log</a></li>
<li><a href="http://developer.android.com/tools/debugging/debugging-log.html" title="DebuggingLogsLogCat">Debugging Logs with LogCat</a></li>
</ul>
<h5 id="tools-1">Tools</h5>
<ul>
<li><a href="http://developer.android.com/tools/help/logcat.html" title="LogCat">LogCat</a></li>
<li><a href="http://proguard.sourceforge.net/" title="ProGuard">ProGuard</a></li>
<li><a href="https://www.guardsquare.com/dexguard" title="DexGuard">DexGuard</a></li>
<li><a href="https://github.com/google/android-classyshark" title="ClassyShark">ClassyShark</a></li>
</ul>
<h5 id="owasp-masvs-2">OWASP MASVS</h5>
<ul>
<li>V2.2: &quot;No sensitive data is written to application logs.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-2">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-2">CWE</h5>
<ul>
<li>CWE-117: Improper Output Neutralization for Logs</li>
<li>CWE-532: Information Exposure Through Log Files</li>
<li>CWE-534: Information Exposure Through Debug Log Files</li>
</ul>
<h3 id="omtg-datast-003-test-for-sensitive-information-in-cloud-storage-1"><a name="OMTG-DATAST-003"></a>OMTG-DATAST-003: Test for Sensitive Information in Cloud Storage</h3>
<h4 id="overview-4">Overview</h4>
<p>Android provides two ways for apps to backup their data to the cloud:</p>
<ul>
<li>Auto Backup for Apps (available &gt;= API level 23), which uploads the data to the users Google Drive account.</li>
<li>Key/Value Backup (Backup API), which uploads the data to the Anrdoid Backup Service.</li>
</ul>
<h4 id="white-box-testing-6">White-box Testing</h4>
<p>Two mechanisms can be used for cloud storage in Android.</p>
<h5 id="keyvalue-backup">Key/Value Backup</h5>
<p>To enable key/value backup the backup agent need to be defined in the manifest file. Look in <code>AndroidManifest.xml</code> for the following attribute:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">android:backupAgent</code></pre></div>
<p>To implement the key/value backup, either one of the following classes need to be extended:</p>
<ul>
<li>BackupAgent</li>
<li>BackupAgentHelper</li>
</ul>
<h5 id="auto-backup">Auto Backup</h5>
<p>When using the following attribute in the manifest file, auto backup is used instead of key/value backup:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">android:fullBackupOnly</code></pre></div>
<p>Auto backup includes almost all of the app's files and stores them in the Google Drive account of the user.</p>
<p>If either key/value or auto backup is used it need to be identified:</p>
<ul>
<li>what files are sent to the cloud (e.g. SharedPreferences),</li>
<li>if the files contain sensitive information,</li>
<li>if sensitive information is protected through encryption before sending it to the cloud.</li>
</ul>
<h4 id="black-box-testing-6">Black-box Testing</h4>
<p>The APK should be decompiled in order to read the manifest file. According to the attributes set, it can be identified if backup features are used or not. See White-box testing for details.</p>
<h4 id="remediation-3">Remediation</h4>
<p>Sensitive information should not be sent in clear text to the cloud. It should either be:</p>
<ul>
<li>avoided to store the information in the first place or</li>
<li>encrypt the information in rest, before sending it to the cloud.</li>
</ul>
<p>Files can also be excluded from Auto Backup, in case they should not be shared with the Google Cloud, see <a href="https://developer.android.com/guide/topics/data/autobackup.html#IncludingFiles" title="IncludingFiles">including files</a>.</p>
<h4 id="references-5">References</h4>
<ul>
<li><a href="https://developer.android.com/guide/topics/data/backup.html" title="BackingUpAppDataToCloud">Backing up App Data to the Cloud</a></li>
<li><a href="https://developer.android.com/guide/topics/data/keyvaluebackup.html" title="KeyValueBackup">Key/Value Backup</a></li>
<li><a href="https://developer.android.com/reference/android/app/backup/BackupAgentHelper.html" title="BackupAgentHelper">BackupAgentHelper</a></li>
<li><a href="https://developer.android.com/reference/android/app/backup/BackupAgent.html" title="BackupAgent">BackupAgent</a></li>
<li><a href="https://developer.android.com/guide/topics/data/autobackup.html" title="AutoBackup">Auto Backup</a></li>
</ul>
<h5 id="owasp-masvs-3">OWASP MASVS</h5>
<ul>
<li>V2.3: &quot;No sensitive data is synced cloud storage.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-3">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-3">CWE</h5>
<ul>
<li>CWE-200: Information Exposure [<a href="https://cwe.mitre.org/data/definitions/200.html" class="uri">https://cwe.mitre.org/data/definitions/200.html</a>]</li>
</ul>
<h3 id="omtg-datast-004-test-data-communication-with-third-parties-1"><a name="OMTG-DATAST-004"></a>OMTG-DATAST-004: Test Data Communication with Third Parties</h3>
<h4 id="overview-5">Overview</h4>
<p>Different 3rd party services are available that can be embedded into the App to implement different features. This features can vary from tracker services to monitor the user behaviour within the App, selling banner advertisements or to create a better user experience. Interacting with these services abstracts the complexity and neediness to implement the functionality on it’s own and to reinvent the wheel.<br />
The downside is that a developer doesn’t know in detail what code is executed via 3rd party libraries and therefore giving up visibility. Consequently it should be ensured that not more information as needed is sent to the service and that no sensitive information is disclosed.</p>
<p>3rd party services are mostly implemented in two ways:</p>
<ul>
<li>By using a standalone library, like a Jar in an Android project that is getting included into the APK.</li>
<li>By using a full SDK.</li>
</ul>
<h4 id="white-box-testing-7">White-box Testing</h4>
<p>Some 3rd party libraries can be automatically integrated into the App through a wizard within the IDE. The permissions set in the <code>AnroidManifest.xml</code> when installing a library through an IDE wizard should be reviewed. Especially permissions to access <code>SMS (READ_SMS)</code>, contacts (<code>READ_CONTACTS</code>) or the location (<code>ACCESS_FINE_LOCATION</code>) should be challenged if they are really needed to make the library work at a bare minimum, see also OMTG-ENV-XXX. When talking to developers it should be shared to them that it’s actually necessary to have a look at the diff on the project source code before and after the library was installed through the IDE and what changes have been made to the code base.</p>
<p>The same thing applies when adding a library manually. The source code should be checked for API calls or functions provided by the 3rd party library. The applied code changes should be reviewed and it should be checked if available security best practices of the library are applied and used.</p>
<h4 id="black-box-testing-7">Black-box Testing</h4>
<p>All requests made to the external service should be analyzed if any sensitive information is embedded into them.</p>
<ul>
<li>Dynamic analysis can be performed launching a MITM attack using <em>Burp Proxy</em>, to intercept the traffic exchanged between client and server. Using the certificate provided by Portswigger, Burp can intercept and decrypt the traffic on the fly and manipulate it as you prefer. First of all we need to setup Burp, on our laptop, to listen on a specific port from all the interfaces. After that we can setup the Android device to redirect all the traffic to our laptop, i.e. setting our laptop IP address like proxy.<br />
A complete guide can be found <a href="https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp" title="ConfigureAndroidBurp">here</a>. Once we are able to route the traffic to burp, we can try to sniff the traffic from the application. When using the App all requests that are not going directly to the server where the main function is hosted should be checked, if any sensitive information is sent to a 3rd party. This could be for example PII in a tracker or ad service.</li>
<li>When decompiling the App, API calls and/or functions provided through the 3rd party library should be reviewed on a source code level to identify if they are used accordingly to best practices.<br />
The Jar files loaded into the project should be reviewed in order to identify with the developers if they are needed and also if they are out of date and contain known vulnerabilities.</li>
</ul>
<h4 id="remediation-4">Remediation</h4>
<p>All data that is sent to 3rd Party services should be anonymized, so no PII data is available. Also all other data, like IDs in an application that can be mapped to a user account or session should not be sent to a third party.<br />
<code>AndroidManifest.xml</code> should only contain the permissions that are absolutely needed to work properly and as intended.</p>
<h4 id="references-6">References</h4>
<ul>
<li><a href="https://www.amazon.com/Bulletproof-Android-Practical-Building-Developers/dp/0133993329" title="Book_BulletproofAndroid">Bulletproof Android, Godfrey Nolan</a>: Chapter 7 - Third-Party Library Integration</li>
</ul>
<h5 id="owasp-masvs-4">OWASP MASVS</h5>
<ul>
<li>V2.4: &quot;No sensitive data is sent to third parties.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-4">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-4">CWE</h5>
<ul>
<li>CWE-359 &quot;Exposure of Private Information ('Privacy Violation')&quot;: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-005-test-for-sensitive-data-in-the-keyboard-cache-1"><a name="OMTG-DATAST-005"></a>OMTG-DATAST-005: Test for Sensitive Data in the Keyboard Cache</h3>
<h4 id="overview-6">Overview</h4>
<p>When keying in data into input fields, the software keyboard automatically suggests what data the user might want to key in. This feature can be very useful in messaging Apps to write text messages more efficient. For input fields that are asking for sensitive information like passwords or credit card data the keyboard cache might disclose sensitive information already when the input field is selected. This feature should therefore be disabled for input fields that are asking for sensitive information.</p>
<h4 id="white-box-testing-8">White-box Testing</h4>
<p>In the layout definition of an activity TextViews can be defined that have XML attributes. When the XML attribute android:inputType is set with the constant &quot;textNoSuggestions&quot; the keyboard cache is not shown if the input field is selected. Only the keyboard is shown and the user needs to type everytyhing manually and nothing is suggested to him.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">   <span class="kw">&lt;EditText</span>
<span class="ot">        android:id=</span><span class="st">&quot;@+id/KeyBoardCache&quot;</span>
<span class="ot">        android:inputType=</span><span class="st">&quot;textNoSuggestions&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<h4 id="black-box-testing-8">Black-box Testing</h4>
<p>Start the app and click into the input fields that ask for sensitive data. If strings are suggested the keyboard cache is not disabled for this input field.</p>
<h4 id="remediation-5">Remediation</h4>
<p>All input fields that ask for sensitive information, should implement the following XML attribute to disable the keyboard suggestions:</p>
<p>android:inputType=&quot;textNoSuggestions&quot;</p>
<h4 id="references-7">References</h4>
<ul>
<li><a href="https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS" class="uri">https://developer.android.com/reference/android/text/InputType.html#TYPE_TEXT_FLAG_NO_SUGGESTIONS</a></li>
</ul>
<h5 id="owasp-masvs-5">OWASP MASVS</h5>
<ul>
<li>V2.5: &quot;The keyboard cache is disabled on text inputs that process sensitive data.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-5">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-5">CWE</h5>
<ul>
<li>CWE-524: Information Exposure Through Caching</li>
</ul>
<h3 id="omtg-datast-006-test-for-sensitive-data-in-the-clipboard-1"><a name="OMTG-DATAST-006"></a>OMTG-DATAST-006: Test for Sensitive Data in the Clipboard</h3>
<h4 id="overview-7">Overview</h4>
<p>(... TODO ...)</p>
<h4 id="white-box-testing-9">White-box Testing</h4>
<p>Input fields that are asking for sensitive information need to be identified and afterwards be investiagated if any countermeasures are in place to mitigate the clipboard of showing up. See the remediation section for code snippets that could be applied.</p>
<h4 id="black-box-testing-9">Black-box Testing</h4>
<p>Start the app and click into the input fields that ask for sensitive data. When it's possible to get the menu to copy/paste data the functionality is not disabled for this input field.</p>
<h4 id="remediation-6">Remediation</h4>
<p>Many major versions of the operating system are still activively used and are outta there. On top of that several mobile phone manufactures are implementing their own user interface extensions and functions to their Android fork. Because of this it might be difficult to deactivate the clipboard completelty on every single Android device.</p>
<p>A general best practice is overwritting different functions in the input field to disable the clipboard specifically for it.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">EditText  etxt = (EditText) <span class="fu">findViewById</span>(R.<span class="fu">id</span>.<span class="fu">editText1</span>);
etxt.<span class="fu">setCustomSelectionActionModeCallback</span>(<span class="kw">new</span> Callback() {

            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onPrepareActionMode</span>(ActionMode mode, Menu menu) {
                <span class="kw">return</span> <span class="kw">false</span>;
            }

            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onDestroyActionMode</span>(ActionMode mode) {                  
            }

            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onCreateActionMode</span>(ActionMode mode, Menu menu) {
                <span class="kw">return</span> <span class="kw">false</span>;
            }

            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onActionItemClicked</span>(ActionMode mode, MenuItem item) {
                <span class="kw">return</span> <span class="kw">false</span>;
            }
        });</code></pre></div>
<p>Also longclickable should be deactivated for this input field.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">android:longClickable=&quot;false&quot;</code></pre></div>
<h4 id="references-8">References</h4>
<ul>
<li><a href="https://developer.android.com/guide/topics/text/copy-paste.html" class="uri">https://developer.android.com/guide/topics/text/copy-paste.html</a></li>
</ul>
<h5 id="owasp-masvs-6">OWASP MASVS</h5>
<ul>
<li>V2.6: &quot;The clipboard is deactivated on text fields that may contain sensitive data.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-6">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-6">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-007-test-for-sensitive-data-leakage-via-ipc-mechanisms-1"><a name="OMTG-DATAST-007"></a>OMTG-DATAST-007: Test for Sensitive Data Leakage via IPC Mechanisms</h3>
<h4 id="overview-8">Overview</h4>
<p>During development of mobile application, traditional techniques for IPC might be applied like usage of shared files or network sockets. As mobile application platforms implement their own system functionality for IPC these mechanisms should be applied as they are much more mature than traditional techniques. Using IPC mechanisms with no security in mind may cause the application to leak or expose sensitive data.</p>
<p>The following is a list of Android IPC Mechanisms that may expose sensitive data:</p>
<ul>
<li><a href="https://developer.android.com/reference/android/os/Binder.html" title="IPCBinder">Binders</a></li>
<li><a href="https://developer.android.com/guide/components/services.html" title="IPCServices">Services</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html" title="BoundServices">Bound Services</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html" title="AIDL">AIDL</a></li>
<li><a href="https://developer.android.com/reference/android/content/Intent.html" title="IPCIntent">Intents</a></li>
<li><a href="https://developer.android.com/reference/android/content/ContentProvider.html" title="IPCContentProviders">ContentProviders</a></li>
</ul>
<h4 id="white-box-testing-10">White-box Testing</h4>
<p>The first step is to look into the <code>AndroidManifest.xml</code> in order to detect and identify IPC mechanisms exposed by the applications. You will want to identify elements such as:</p>
<ul>
<li><code>&lt;intent-filter&gt;</code>: more <a href="https://developer.android.com/guide/topics/manifest/intent-filter-element.html" title="IntentFilterElement">here</a></li>
<li><code>&lt;service&gt;</code>: more <a href="https://developer.android.com/guide/topics/manifest/service-element.html" title="ServiceElement">here</a></li>
<li><code>&lt;provider&gt;</code>: more <a href="https://developer.android.com/guide/topics/manifest/provider-element.html" title="ProviderElement">here</a></li>
<li><code>&lt;receiver&gt;</code>: more <a href="https://developer.android.com/guide/topics/manifest/receiver-element.html" title="ReceiverElement">here</a></li>
</ul>
<p>Except for the <code>&lt;intent-filter&gt;</code> element, check if the the previous elements contain the following attributes:</p>
<ul>
<li><code>android:exported</code></li>
<li><code>android:permission</code></li>
</ul>
<p>Once you identify a list of IPC mechanisms, review the source code in order to detect if they leak any sensitive data when used. For example, <em>ContentProviders</em> can be used to access database information, while services can be probed to see if they return data. Also BroadcastReceiver and Broadcast intents can leak sensitive information if probed or sniffed.</p>
<ul>
<li>Vulnerable ContentProvider</li>
</ul>
<p>An example of vulnerable <em>ContentProvider</em> (and SQL injection <strong>#TODO: refere any input validation test in the project</strong>)</p>
<ul>
<li><code>AndroidManifest.xml</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">...
<span class="kw">&lt;provider</span><span class="ot"> android:name=</span><span class="st">&quot;.CredentialProvider&quot;</span>
<span class="ot">          android:authorities=</span><span class="st">&quot;com.owaspomtg.vulnapp.provider.CredentialProvider&quot;</span>
<span class="ot">          android:exported=</span><span class="st">&quot;true&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/provider&gt;</span>
...</code></pre></div>
<p>The application exposes the content provider. In the <code>CredentialProvider.java</code> file we have to inspect the <code>query</code> function to detect if any sensitive information will be leaked:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">...
<span class="kw">public</span> Cursor <span class="fu">query</span>(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
         SQLiteQueryBuilder queryBuilder = <span class="kw">new</span> <span class="fu">SQLiteQueryBuilder</span>();
         <span class="co">// the TABLE_NAME to query on</span>
         queryBuilder.<span class="fu">setTables</span>(TABLE_NAME);
          <span class="kw">switch</span> (uriMatcher.<span class="fu">match</span>(uri)) {
          <span class="co">// maps all database column names</span>
          <span class="kw">case</span> CREDENTIALS:
              queryBuilder.<span class="fu">setProjectionMap</span>(CredMap);
             <span class="kw">break</span>;
          <span class="kw">case</span> CREDENTIALS_ID:
              queryBuilder.<span class="fu">appendWhere</span>( ID + <span class="st">&quot;=&quot;</span> + uri.<span class="fu">getLastPathSegment</span>());
             <span class="kw">break</span>;
          <span class="kw">default</span>:
             <span class="kw">throw</span> <span class="kw">new</span> IllegalArgumentException(<span class="st">&quot;Unknown URI &quot;</span> + uri);
          }
          <span class="kw">if</span> (sortOrder == <span class="kw">null</span> || sortOrder == <span class="st">&quot;&quot;</span>){
             sortOrder = USERNAME;
          }
         Cursor cursor = queryBuilder.<span class="fu">query</span>(database, projection, selection,
                  selectionArgs, <span class="kw">null</span>, <span class="kw">null</span>, sortOrder);
          cursor.<span class="fu">setNotificationUri</span>(<span class="fu">getContext</span>().<span class="fu">getContentResolver</span>(), uri);
          <span class="kw">return</span> cursor;
    }
...</code></pre></div>
<ul>
<li>Vulnerable Broadcast<br />
Search in the source code for strings like <code>sendBroadcast</code>, <code>sendOrderedBroadcast</code>, <code>sendStickyBroadcast</code> and verify that the application doesn't send any sensitive data.</li>
</ul>
<p>An example of a vulnerable broadcast is the following:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">private</span> <span class="dt">void</span> <span class="fu">vulnerableBroadcastFunction</span>() {
    <span class="co">// ...</span>
    Intent VulnIntent = <span class="kw">new</span> <span class="fu">Intent</span>();
    VulnIntent.<span class="fu">setAction</span>(<span class="st">&quot;com.owasp.omtg.receiveInfo&quot;</span>);
    VulnIntent.<span class="fu">putExtra</span>(<span class="st">&quot;ApplicationSession&quot;</span>, <span class="st">&quot;SESSIONID=A4EBFB8366004B3369044EE985617DF9&quot;</span>);
    VulnIntent.<span class="fu">putExtra</span>(<span class="st">&quot;Username&quot;</span>, <span class="st">&quot;litnsarf_omtg&quot;</span>);
    VulnIntent.<span class="fu">putExtra</span>(<span class="st">&quot;Group&quot;</span>, <span class="st">&quot;admin&quot;</span>);
  }
  <span class="kw">this</span>.<span class="fu">sendBroadcast</span>(VulnIntent);</code></pre></div>
<h4 id="black-box-testing-10">Black-box Testing</h4>
<p>Similar to the White-box pentesting, you should decompile the application (if possibile) and create a list of IPC mechanisms implemented by going through the AndroidManifest.xml. Once you have the list, prove each IPC via ADB or custom applications to see if they leak any sensitive information.</p>
<ul>
<li>Vulnerable ContentProvider</li>
</ul>
<p>In the case of the previous content provider, we can probe the content provider via ADB, but we need to know the correct URI. Once the APK has been decompiled, use the commands <code>strings</code> and <code>grep</code> to identify the correct URI to use:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">strings</span> classes.dex <span class="kw">|</span> <span class="kw">grep</span> <span class="st">&quot;content://&quot;</span>
<span class="kw">com.owaspomtg.vulnapp.provider.CredentialProvider/credentials</span></code></pre></div>
<p>Now you can probe the content provider via <code>adb</code> with the following command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">$adb</span> <span class="kw">shell</span> content query --uri content://com.owaspomtg.vulnapp.provider.CredentialProvider/credentials
<span class="kw">Row</span>: 0 id=1, username=admin, password=StrongPwd
<span class="kw">Row</span>: 1 id=2, username=test, password=test
<span class="kw">...</span></code></pre></div>
<ul>
<li>Vulnerable Broadcast</li>
</ul>
<p>To sniff intents install and run the application on a device (actual device or emulated device) and use tools like <a href="https://labs.mwrinfosecurity.com/tools/drozer/" title="Drozer">drozer</a> or <a href="https://www.nccgroup.trust/us/about-us/resources/intent-sniffer/" title="IntentSniffer">Intent Sniffer</a> to capture intents and broadcast messages.</p>
<h4 id="remediation-7">Remediation</h4>
<p>For an <em>activity</em>, <em>broadcast</em> and <em>service</em> the permission of the caller can be checked either by code or in the manifest.</p>
<p>If not strictly required, be sure that your IPC does not have the <code>android:exported=&quot;true&quot;</code> value in the <code>AndroidManifest.xml</code>, as otherwise this allows all other Apps on Andorid to communicate and invoke it.</p>
<p>If the <em>intent</em> is only broadcast/received in the same application, <code>LocalBroadcastManager</code> can be used so that, by design, other apps cannot receive the broadcast message, which reduces the risk of leaking sensitive information (<code>LocalBroadcastManager.sendBroadcast()). BroadcastReceivers</code> should make use of the <code>android:permission</code> attribute, as otherwise any other application can invoke them. <code>Context.sendBroadcast(intent, receiverPermission);</code> can be used to specify permissions a receiver needs to have to read the broadcast. See also <a href="https://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)" title="SendBroadcast">sendBroadcast</a>.<br />
You can also set an explicit application package name that limits the components this Intent will resolve to. If left to the default value of null, all components in all applications will considered. If non-null, the Intent can only match the components in the given application package.</p>
<p>If your IPC is intended to be accessible to other applications, you can apply a security policy by using the <code>&lt;permission&gt;</code> element and set a proper <code>android:protectionLevel</code>. When using <code>android:permission</code> in a service declaration, other applications will need to declare a corresponding <code>&lt;uses-permission&gt;</code> element in their own manifest to be able to start, stop, or bind to the service.</p>
<h4 id="references-9">References</h4>
<ul>
<li><a href="https://developer.android.com/reference/android/os/Binder.html" title="IPCBinder">Binders</a></li>
<li><a href="https://developer.android.com/guide/components/services.html" title="IPCServices">Services</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html" title="BoundServices">Bound Services</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html" title="AIDL">AIDL</a></li>
<li><a href="https://developer.android.com/reference/android/content/Intent.html" title="IPCIntent">Intents</a></li>
<li><a href="https://developer.android.com/reference/android/content/ContentProvider.html" title="IPCContentProviders">ContentProviders</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/intent-filter-element.html" title="IntentFilterElement">Intent-filter</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/service-element.html" title="ServiceElement">Service</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/provider-element.html" title="ProviderElement">Provider</a></li>
<li><a href="https://developer.android.com/guide/topics/manifest/receiver-element.html" title="ReceiverElement">Receiver</a></li>
<li><a href="https://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)" title="SendBroadcast">SendBroadcast</a></li>
</ul>
<h5 id="owasp-masvs-7">OWASP MASVS</h5>
<ul>
<li>V2.7: &quot;No sensitive data is exposed via IPC mechanisms.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-7">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-7">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-008-test-for-sensitive-data-in-the-user-interface-and-screenshots-1"><a name="OMTG-DATAST-008"></a>OMTG-DATAST-008: Test for Sensitive Data in the User Interface and Screenshots</h3>
<h4 id="overview-9">Overview</h4>
<p>Sensitive data could be exposed if a user deliberately takes a screenshot of the application (containing sensitive data), or in the case of malicious application running on the device, that is able to continuously capture the screen. For example, capturing a screenshot of a bank application running on the device may reveal information about the user account, his credit, transactions and so on.</p>
<h4 id="white-box-testing-11">White-box Testing</h4>
<p>To verify if the application may expose sensitive information via the user interface or screenshot, detect if the <code>[FLAG_SECURE][ee87d351]</code> options is set in the activity that needs to be protected.</p>
<p>You should be able to find something similar to the following line.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">LayoutParams.<span class="fu">FLAG_SECURE</span></code></pre></div>
<p>If not, the application is probably vulnerable to screen capturing.</p>
<h3 id="black-box-testing-11">Black-box Testing</h3>
<p>To analyse if the application leaks any sensitive information, run the application on a device and try to acquire a screenshot of the activity or activities you want to test.</p>
<p>Steps to reproduce:</p>
<ul>
<li>Install the application on an actual device or emulator</li>
<li><code>adb shell install &lt;apk_name&gt;</code></li>
<li>Run the application</li>
<li>Take a screenshot and save in the current folder</li>
<li><code>adb shell screencap -p /sdcard/screencap.png &amp;&amp; adb pull /sdcard/screencap.png</code></li>
</ul>
<p>If you can see the application screenshot, the application is vulnerable; otherwise you will obtain a file of 0 bytes.</p>
<p><img src="../images/Testcases/OMTG_DATAST_008.png" alt="OMTG_DATAST_008_FLAG_SECURE" /></p>
<h4 id="remediation-8">Remediation</h4>
<p>In order to prevent user or malicious applications to capture the screen of a specific activity, add the following code in the <code>my_app.java</code> activity file that you want to protect, and then call <code>setContentView</code>:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">getWindow</span>().<span class="fu">setFlags</span>(WindowManager.<span class="fu">LayoutParams</span>.<span class="fu">FLAG_SECURE</span>,
                WindowManager.<span class="fu">LayoutParams</span>.<span class="fu">FLAG_SECURE</span>);

<span class="fu">setContentView</span>(R.<span class="fu">layout</span>.<span class="fu">activity_main</span>);</code></pre></div>
<p>Note that this would automatically prevent the user from taking a manual screenshot. But even if the activity is tagged with <code>FLAG_SECURE</code>, this does not apply to any pop-up windows such as Dialogs, Toasts, etc.</p>
<h4 id="references-10">References</h4>
<ul>
<li><a href="ee87d351">FLAG_SECURE</a></li>
</ul>
<h5 id="owasp-masvs-8">OWASP MASVS</h5>
<ul>
<li>V2.8: &quot;No sensitive data, such as passwords and credit card numbers, is exposed through the user interface or leaks to screenshots.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-8">OWASP Mobile Top 10</h5>
<ul>
<li>M4 - Unintended Data Leakage</li>
</ul>
<h5 id="cwe-8">CWE</h5>
<ul>
<li>CWE-200: Information Exposure [<a href="https://cwe.mitre.org/data/definitions/200.html" class="uri">https://cwe.mitre.org/data/definitions/200.html</a>]</li>
</ul>
<h3 id="omtg-datast-009-test-for-sensitive-data-in-backups-1"><a name="OMTG-DATAST-009"></a>OMTG-DATAST-009: Test for Sensitive Data in Backups</h3>
<h4 id="overview-10">Overview</h4>
<p>When backup options are available, it is important to consider that user data may be stored within application configuration data. This feature could potentially leak sensitive information such as sessions, usernames, emails, passwords, keys and much more.<br />
Consider to encrypt backup data and avoid to store any sensitive information that is not strictly required.</p>
<h4 id="white-box-testing-12">White-box Testing</h4>
<p>In order to backup all your application’s data Android provides an attribute called <code>allowBackup</code>. This attribute is set within the <code>AndroidManifest.xml</code> file. If the value of this attribute is set to <strong>true</strong>, then the device allows user to backup the application using Android Debug Bridge (ADB) - <code>$ adb backup</code>.</p>
<blockquote>
<p>Note: If the device was encrypted, then the backup files will be encrypted as well.</p>
</blockquote>
<p>Check the <code>AndroidManifest.xml</code> file for the following flag:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">android:allowBackup=&quot;true&quot;</code></pre></div>
<p>If the value is set to <strong>true</strong>, investigate whether the app saves any kind of sensitive data, either by reading the source code, or inspecting the files in the app's data directory.</p>
<h4 id="black-box-testing-12">Black-box Testing</h4>
<p>Attempt to make a backup using <code>adb</code> and, if successful, inspect the backup archive for sensitive data. Open a terminal and run the following command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">adb</span> backup -apk -nosystem packageNameOfTheDesiredAPK</code></pre></div>
<p>Approve the backup from your device by selecting the &quot;<em>Back up my data</em>&quot; option. After the backup process is finished, you will have a <em>.ab</em> file in your current working directory.<br />
Run the following command to convert the .ab file into a .tar file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">dd</span> if=mybackup.ab bs=24 skip=1<span class="kw">|openssl</span> zlib -d <span class="kw">&gt;</span> mybackup.tar</code></pre></div>
<p>Alternatively, use the <a href="https://sourceforge.net/projects/adbextractor/">Android Backup Extractor</a> for this task. To install, download the <a href="https://sourceforge.net/projects/adbextractor/files/latest/download">binary distribution</a>. For the tool to work, you also have to download the <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Oracle JCE Unlimited Strength Jurisdiction Policy Files for JRE7</a> or <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JRE8</a>, and place them in the JRE lib/security folder. Run the following command to convert the tar file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">java</span> -jar android-backup-extractor-20160710-bin/abe.jar unpack backup.ab</code></pre></div>
<p>Extract the tar file into your current working directory to perform your analysis for sensitive data.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tar</span> xvf mybackup.tar</code></pre></div>
<h4 id="remediation-9">Remediation</h4>
<p>To prevent backing up the app's data, set the <code>android:allowBackup</code> attribute must be set to <strong>false</strong> in <code>AndroidManifest.xml</code>.</p>
<h4 id="references-11">References</h4>
<ul>
<li>Documentation for the Application tag: <a href="https://developer.android.com/guide/topics/manifest/application-element.html#allowbackup" class="uri">https://developer.android.com/guide/topics/manifest/application-element.html#allowbackup</a></li>
</ul>
<h5 id="owasp-masvs-9">OWASP MASVS</h5>
<ul>
<li>V2.9: &quot;No sensitive data is included in backups.&quot;</li>
<li><a href="https://cwe.mitre.org/data/definitions/530.html">CWE-530</a></li>
</ul>
<h5 id="owasp-mobile-top-10-9">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-9">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-010-test-for-sensitive-data-in-the-backgrounded-app-1"><a name="OMTG-DATAST-010"></a>OMTG-DATAST-010: Test for Sensitive Data in the Backgrounded App</h3>
<h4 id="overview-11">Overview</h4>
<p>Manufacturers want to provide device users an aesthetically pleasing effect when an application is entered or exited, hence they introduced the concept of saving a screenshot when the application goes into the background. This feature could potentially pose a security risk for an application, as the screenshot containing sensitive information (e.g. a screenshot of an email or corporate documents) is written to local storage, where it is recovered either by a rogue application on a jailbroken device, or by someone who steals the device.</p>
<h4 id="white-box-testing-13">White-box Testing</h4>
<p>In Android, when the app goes into background a screenshot of the current activity is taken and is used to give a pleasing effect when the app is next entered. However, this would leak sensitive information that is present within the app.</p>
<p>To verify if the application may expose sensitive information via task switcher, detect if the <code>[FLAG_SECURE][ee87d351]</code> options is set. You should be able to find something similar to the following line.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">LayoutParams.<span class="fu">FLAG_SECURE</span></code></pre></div>
<p>If not, the application is probably vulnerable to screen capturing.</p>
<h4 id="black-box-testing-13">Black-box Testing</h4>
<p>During black-box testing, open any screen within the app that contains sensitive information and click on Home button so that the app goes into background. Now press the task-switcher button, to see the snapshot. As showed below, if <code>SECURE_FLAG</code> is set (image on the left), the snapshot is entirely black, while if the <code>SECURE_FLAG</code> is not set (image on the right), information within the activity are showed:</p>
<table>
<thead>
<tr class="header">
<th><code>SECURE_FLAG</code> not set</th>
<th><code>SECURE_FLAG</code> set</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="../images/Testcases/OMTG_DATAST_010_1.png" alt="OMTG_DATAST_010_1_FLAG_SECURE" /></td>
<td><img src="../images/Testcases/OMTG_DATAST_010_2.png" alt="OMTG_DATAST_010_2_FLAG_SECURE" /></td>
</tr>
</tbody>
</table>
<h4 id="remediation-10">Remediation</h4>
<p>To prevent users or malicious applications access information from backgrounded applications use the <code>SECURE_FLAG</code> as shown below:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">getWindow</span>().<span class="fu">setFlags</span>(WindowManager.<span class="fu">LayoutParams</span>.<span class="fu">FLAG_SECURE</span>,
                WindowManager.<span class="fu">LayoutParams</span>.<span class="fu">FLAG_SECURE</span>);

<span class="fu">setContentView</span>(R.<span class="fu">layout</span>.<span class="fu">activity_main</span>);</code></pre></div>
<p>Moreover, the following suggestions can also be implemented to enhance your application security posture:</p>
<ul>
<li>Quit the app entirely when backgrounded. This will destroy any retained GUI screens.</li>
<li>Nullify the data on a GUI screen before leaving the screen or logging out.</li>
</ul>
<h4 id="references-12">References</h4>
<ul>
<li><p>[link to relevant how-tos, papers, etc.]</p></li>
<li><p><a href="https://cwe.mitre.org/data/definitions/530.html">CWE-530</a></p></li>
</ul>
<h5 id="owasp-masvs-10">OWASP MASVS</h5>
<ul>
<li>V2.10: &quot;The app removes sensitive data from views when backgrounded.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-10">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-10">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<h3 id="omtg-datast-011-test-for-sensitive-data-disclosure-in-process-memory-1"><a name="OMTG-DATAST-011"></a>OMTG-DATAST-011: Test for Sensitive Data Disclosure in Process Memory</h3>
<h4 id="overview-12">Overview</h4>
<p>Analyzing the memory can help to identify the root cause of different problems, like for example why an application is crashing, but can also be used to identify sensitive data. This section describes how to check for sensitive data and disclosure of data in general within the process memory.</p>
<p>To be able to investigate the memory of an application a memory dump needs to be created first or the memory needs to be viewed with real-time updates. This is also already the problem, as the application only stores certain information in memory if certain functions are triggered within the application. Memory investigation can of course be executed randomly in every stage of the application, but it is much more beneficial to understand first what the mobile application is doing and what kind of functionalities it offers and also make a deep dive into the decompiled code before making any memory analysis.<br />
Once sensitive functions are identified (like decryption of data) the investigation of a memory dump might be beneficial in order to identify sensitive data like a key or decrypted information.</p>
<h4 id="white-box-testing-14">White-box Testing</h4>
<p>It needs to be identified within the code when sensitive information is stored within a variable and is therefore available within the memory. This information can then be used in dynamic testing when using the App.</p>
<h4 id="black-box-testing-14">Black-box Testing</h4>
<p>To analyse the memory of an app, the app must be <strong>debuggable</strong>.<br />
See the instructions in XXX (<strong>#TODO-Link to repackage and sign</strong>) on how to repackage and sign an Android App to enable debugging for an app, if not already done. Also ADB integration need to be activated in Android Studio in “<em>Tools/Android/Enable ADB Integration</em>” in order to take a memory dump.</p>
<p>For rudimentary analysis Android Studio built in tools can be used. Android studio includes tools in the “<em>Android Monitor</em>” tab to investigate the memory. Select the device and app you want to analyse in the &quot;<em>Android Monitor</em>&quot; tab and click on &quot;<em>Dump Java Heap</em>&quot; and a <em>.hprof</em> file will be created.</p>
<p><img src="http://bb-conservation.de/sven/mem0.png" alt="Create Heap Dump" /></p>
<p>In the new tab that shows the <em>.hprof</em> file, the Package Tree View should be selected. Afterwards the package name of the app can be used to navigate to the instances of classes that were saved in the memory dump.</p>
<p><img src="http://bb-conservation.de/sven/mem1.png" alt="Create Heap Dump" /></p>
<p>For more deeper analysis of the memory dump Eclipse Memory Analyser (MAT) should be used. The <em>.hprof</em> file will be stored in the directory &quot;captures&quot;, relative to the project path open within Android Studio.</p>
<p>Before the <em>.hprof</em> file can be opened in MAT it needs to be converted. The tool <em>hprof-conf</em> can be found in the Android SDK in the directory platform-tools.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./hprof-conv</span> file.hprof file-converted.hprof</code></pre></div>
<p>By using MAT, more functions are available like usage of the Object Query Language (OQL). OQL is an SQL-like language that can be used to make queries in the memory dump. Analysis should be done on the dominator tree as only this contains the variables/memory of static classes.</p>
<p>To quickly discover potential sensitive data in the <em>.hprof</em> file, it is also useful to run the <code>string</code> command against it. When doing a memory analysis, check for sensitive information like:</p>
<ul>
<li>Password and/or Username</li>
<li>Decrypted information</li>
<li>User or session related information</li>
<li>Session ID</li>
<li>Interaction with OS, e.g. reading file content</li>
</ul>
<h4 id="remediation-11">Remediation</h4>
<p>If sensitive information is used within the application memory it should be nulled immediately after usage to reduce the attack surface. Information should not be stored in clear text in memory (does this make sense?).</p>
<h4 id="references-13">References</h4>
<ul>
<li><a href="https://www.nowsecure.com/resources/secure-mobile-development/coding-practices/securely-store-sensitive-data-in-ram/" title="SecurelyStoreDataInRAM">Securely stores sensitive data in RAM</a></li>
</ul>
<p>Tools:</p>
<ul>
<li><a href="http://developer.android.com/tools/debugging/debugging-memory.html#ViewHeap" title="MemoryMonitor">Android Studio’s Memory Monitor</a></li>
<li><a href="https://eclipse.org/mat/downloads.php" title="EclipseMATStandalone">Eclipse’s MAT (Memory Analyzer Tool) standalone</a></li>
<li><a href="https://www.eclipse.org/downloads/" title="MemoryAnalyzerWhichIsPartOfEclipse">Memory Analyzer which is part of Eclipse</a></li>
<li><a href="http://pentestcorner.com/introduction-to-fridump" title="Fridump">Fridump</a></li>
<li><a href="https://github.com/Nightbringer21/fridump" title="FridumpRepo">Fridump Repo</a></li>
<li><a href="https://github.com/504ensicsLabs/LiME" title="LiME">LiME</a> (formerly DMD)</li>
</ul>
<h5 id="references-14">References</h5>
<ul>
<li><p>OWASP MASVS</p></li>
<li><p>V2.11: &quot;The app does not hold sensitive data in memory longer than necessary, and memory is cleared explicitly after use.&quot;</p></li>
</ul>
<h5 id="owasp-mobile-top-10-11">OWASP Mobile Top 10</h5>
<ul>
<li>M1 - Improper Platform Usage</li>
<li>M2 - Insecure Data Storage</li>
</ul>
<h5 id="cwe-11">CWE</h5>
<ul>
<li>CWE-316 - Cleartext Storage of Sensitive Information in Memory</li>
</ul>
<h3 id="omtg-datast-012-test-remote-locking-and-wiping-1"><a name="OMTG-DATAST-012"></a>OMTG-DATAST-012: Test Remote Locking and Wiping</h3>
<h4 id="overview-13">Overview</h4>
<p>(... TODO ...)</p>
<h4 id="white-box-testing-15">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-15">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-12">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-15">References</h4>
<h5 id="owasp-masvs-11">OWASP-MASVS</h5>
<ul>
<li>V2-12: &quot;If a remote locking mechanism exists, local storage is wiped upon locking.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-12">OWASP Mobile Top 10</h5>
<h5 id="cwe-12">CWE</h5>
<ul>
<li><p>CWE: [Link to CWE issue]</p></li>
<li><p>[link to relevant how-tos, papers, etc.]</p></li>
</ul>
<h3 id="omtg-datast-013-test-enforcement-of-device-access-security-policy-1"><a name="OMTG-DATAST-013"></a>OMTG-DATAST-013: Test Enforcement of Device-Access-Security Policy</h3>
<h4 id="overview-14">Overview</h4>
<p>(... TODO ...)</p>
<h4 id="white-box-testing-16">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-16">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-13">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-16">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h4 id="references-17">References</h4>
<h5 id="owasp-masvs-12">OWASP MASVS</h5>
<ul>
<li>V2-13: &quot;The app enforces a minimum device-access-security policy, such as requiring the user to set a device passcode.&quot;</li>
</ul>
<h5 id="owasp-mobile-top-10-13">OWASP Mobile Top 10</h5>
<h5 id="cwe-13">CWE</h5>
<ul>
<li>CWE: [Link to CWE issue]</li>
</ul>
<!-- References links
If a link is outdated, you can change it here and it will be updated everywhere -->
<!-- OMTG-DATAST-001-1 -->
<!-- OMTG-DATAST-001-2 -->
<!-- OMTG-DATAST-002 -->
<!-- OMTG-DATAST-003 -->
<!-- OMTG-DATAST-011 -->
<!-- OMTG-DATAST-007 -->
<!-- OMTG-DATAST-008 -->
<h3 id="omtg-identifiername"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h3>
<h4 id="overview-15">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-17">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-17">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-14">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-18">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-identifiername-1"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h3>
<h4 id="overview-16">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-18">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-18">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-15">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-19">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-net-004-testing-ssl-pinning-1"><a name="OMTG-NET-004"></a>OMTG-NET-004: Testing SSL Pinning</h3>
<h4 id="overview-17">Overview</h4>
<p>Certificate pinning allows to hard-code in the client the certificate that is known to be used by the server. This technique is used to reduce the threat of a rogue CA and CA compromise. Pinning the server’s certificate take the CA out of games. Mobile applications that implements certificate pinning only have to connect to a limited numbers of server, so a small list of trusted CA can be hard-coded in the application.</p>
<h4 id="white-box-testing-19">White-box Testing</h4>
<p>The process to implement the SSL pinning involves three main steps outlined below:</p>
<ol>
<li>Obtain a certificate for the desired host</li>
<li>Make sure certificate is in .bks format</li>
<li>Pin the certificate to an instance of the default Apache Httpclient.</li>
</ol>
<p>To analyze the correct implementations of the SSL pinning the HTTP client should:</p>
<ol>
<li>Load the keystore:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">InputStream in = resources.<span class="fu">openRawResource</span>(certificateRawResource);
keyStore = KeyStore.<span class="fu">getInstance</span>(<span class="st">&quot;BKS&quot;</span>);
keyStore.<span class="fu">load</span>(resourceStream, password);</code></pre></div>
<p>Once the keystore is loaded we can use the TrustManager that trusts the CAs in our KeyStore :</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">String tmfAlgorithm = TrustManagerFactory.<span class="fu">getDefaultAlgorithm</span>();
TrustManagerFactory tmf = TrustManagerFactory.<span class="fu">getInstance</span>(tmfAlgorithm);
tmf.<span class="fu">init</span>(keyStore);
Create an SSLContext that uses the TrustManager
<span class="co">// SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);</span>
sslContext.<span class="fu">init</span>(<span class="kw">null</span>, tmf.<span class="fu">getTrustManagers</span>(), <span class="kw">null</span>);</code></pre></div>
<h4 id="black-box-testing-19">Black-box Testing</h4>
<p>Black-box Testing can be performed by launching a MITM attack using your prefered Web Proxy to intercept the traffic exchanged between client (mobile application) and the backend server. If the Proxy is unable to intercept the HTTP requests/responses, the SSL pinning is correctly implemented.</p>
<h4 id="remediation-16">Remediation</h4>
<p>The SSL pinning process should be implemented as described on the static analysis section.</p>
<h4 id="references-20">References</h4>
<ul>
<li>Setting Burp Suite as a proxy for Android Devices : <a href="https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp" class="uri">https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp</a>)</li>
<li>OWASP - Certificate Pinning for Android : <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#Android" class="uri">https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#Android</a></li>
</ul>
<h3 id="omtg-identifiername-2"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h3>
<h4 id="overview-18">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-20">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-20">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-17">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-21">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-001-verify-that-the-app-is-propertly-signed"><a name="OMTG-CODE-001"></a>OMTG-CODE-001: Verify that the App is Propertly Signed</h3>
<h4 id="overview-19">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-21">White-box Testing</h4>
<h4 id="black-box-testing-21">Black-box Testing</h4>
<h4 id="remediation-18">Remediation</h4>
<h4 id="references-22">References</h4>
<ul>
<li>Configuring your application for release - <a href="http://developer.android.com/tools/publishing/preparing.html#publishing-configure" class="uri">http://developer.android.com/tools/publishing/preparing.html#publishing-configure</a></li>
<li>Debugging with Android Studio - <a href="http://developer.android.com/tools/debugging/debugging-studio.html" class="uri">http://developer.android.com/tools/debugging/debugging-studio.html</a></li>
</ul>
<h5 id="owasp-masvs-13">OWASP MASVS</h5>
<ul>
<li>V7.1: &quot;The app is signed and provisioned with valid certificate.&quot;</li>
</ul>
<h3 id="omtg-code-002-test-whether-the-app-is-debuggable"><a name="OMTG-CODE-002"></a>OMTG-CODE-002: Test whether the App is Debuggable</h3>
<h4 id="overview-20">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-22">White-box Testing</h4>
<p>Check the AndroidManifest.xml for the value of &quot;android:debuggable&quot; attribute within the application element :</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;manifest</span><span class="ot"> xmlns:android=</span><span class="st">&quot;http://schemas.android.com/apk/res/android&quot;</span><span class="ot"> package=</span><span class="st">&quot;com.android.owasp&quot;</span><span class="kw">&gt;</span>
    
    ...
    
    <span class="kw">&lt;application</span><span class="ot"> android:allowBackup=</span><span class="st">&quot;true&quot;</span><span class="ot"> android:debuggable=</span><span class="st">&quot;true&quot;</span><span class="ot"> android:icon=</span><span class="st">&quot;@drawable/ic_launcher&quot;</span><span class="ot"> android:label=</span><span class="st">&quot;@string/app_name&quot;</span><span class="ot"> android:theme=</span><span class="st">&quot;@style/AppTheme&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;meta-data</span><span class="ot"> android:name=</span><span class="st">&quot;com.owasp.main&quot;</span><span class="ot"> android:value=</span><span class="st">&quot;.Hook&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;/application&gt;</span>
<span class="kw">&lt;/manifest&gt;</span></code></pre></div>
<p>This setting specifies whether or not the application can be debugged, even when running on a device in user mode. A value of &quot;true&quot; if it can be, And &quot;false&quot; if not. The default value is &quot;false&quot;.</p>
<p>A comprehensive guide to debug an Android application can be found within the official documentation by Android (see references).</p>
<h4 id="black-box-testing-22">Black-box Testing</h4>
<h5 id="static-test">Static Test</h5>
<p>When targetting a compiled Android application, the most reliable method is to first decompile it in order to obtain the AndroidManifest.xml file (see Decompiling Android App Guide - #TODO-Create a general guide that can bee referenced anywhere in the OMSTF) and check the value of &quot;android:debuggable&quot; attribute.</p>
<p>Otherwise, use the Android Asset Packaging Tool (aapt) to check the debuggable flag :</p>
<pre><code>$ aapt l -a /path/to/apk/file.apk | grep debuggable</code></pre>
<p>Will return the following if android:debuggable parameter is set to true :</p>
<pre><code>      A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</code></pre>
<h5 id="dynamic-test">Dynamic Test</h5>
<p>Attempt to attach a debugger to the running process. This should either fail, or the app should terminate or misbehave when the debugger has been detected. For example, if ptrace(PT_DENY_ATTACH) has been called, gdb will crash with a segmentation fault:</p>
<p>(TODO example)</p>
<p>(TODO JDWP)</p>
<p>Note that some anti-debugging implementations respond in a stealthy way so that changes in behaviour are not immediately apparent. For example, a soft token app might not visibly respond when a debugger is detected, but instead secretly alter the state of an internal variable so that an incorrect OTP is generated at a later point. Make sure to run through the complete workflow to determine if attaching the debugger causes a crash or malfunction.</p>
<h4 id="remediation-19">Remediation</h4>
<p>For production releases, the attribute android:debuggable must be set to false within the application element. This ensures that a debugger cannot attach to the process of the application.</p>
<h4 id="references-23">References</h4>
<ul>
<li>Configuring your application for release - <a href="http://developer.android.com/tools/publishing/preparing.html#publishing-configure" class="uri">http://developer.android.com/tools/publishing/preparing.html#publishing-configure</a></li>
<li>Debugging with Android Studio - <a href="http://developer.android.com/tools/debugging/debugging-studio.html" class="uri">http://developer.android.com/tools/debugging/debugging-studio.html</a></li>
</ul>
<h3 id="omtg-code-003-verify-that-debugging-symbols-have-been-removed"><a name="OMTG-CODE-003"></a>OMTG-CODE-003: Verify that Debugging Symbols Have Been Removed</h3>
<h4 id="overview-21">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-23">White-box Testing</h4>
<h4 id="black-box-testing-23">Black-box Testing</h4>
<p>Symbols are usually stripped during the build process, so you need the compiled bytecode and libraries to verify whether the any unnecessary metadata has been discarded. For native binaries, use a standard tool like nm or objdump to inspect the symbol table. For example:</p>
<pre><code>berndt@osboxes:~/ $ objdump -t my_library.so
my_library.so:     file format elf32-little

SYMBOL TABLE:
no symbols</code></pre>
<p>Alternatively, open the file in your favorite disassembler and look for debugging symbols. For native libraries, it should be checked that the names of exports don’t give away the location of sensitive functions.</p>
<h4 id="remediation-20">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-24">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-004-test-for-debugging-code-and-verbose-error-logging"><a name="OMTG-CODE-004"></a>OMTG-CODE-004: Test for Debugging Code and Verbose Error Logging</h3>
<h4 id="overview-22">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-24">White-box Testing</h4>
<h4 id="black-box-testing-24">Black-box Testing</h4>
<h4 id="remediation-21">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-25">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-005-test-exception-handling"><a name="OMTG-CODE-005"></a>OMTG-CODE-005: Test Exception Handling</h3>
<h4 id="overview-23">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-25">White-box Testing</h4>
<p>Review the source code to understand/identify who the application handle various types of errors (IPC communications, remote services invokation, etc). Here are some examples of the checks to be performed at this stage :</p>
<ul>
<li>Verify that the application use a [well-designed] (<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047" class="uri">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047</a>) (an unified) scheme to handle exceptions.</li>
<li>Verify that the application doesn't expose sensitive information while handeling exceptions, but are still verbose enough to explain the issue to the user.</li>
<li>C3</li>
</ul>
<h4 id="black-box-testing-25">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-22">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-26">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-006-verify-that-the-app-fails-securely"><a name="OMTG-CODE-006"></a>OMTG-CODE-006: Verify that the App Fails Securely</h3>
<h4 id="overview-24">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-26">White-box Testing</h4>
<h4 id="black-box-testing-26">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-23">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-27">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-007-test-input-validation"><a name="OMTG-CODE-007"></a>OMTG-CODE-007: Test Input Validation</h3>
<h4 id="overview-25">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-27">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-27">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-24">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-28">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-008-test-memory-management"><a name="OMTG-CODE-008"></a>OMTG-CODE-008: Test Memory Management</h3>
<h4 id="overview-26">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-28">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-28">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-25">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-29">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-009-test-compiler-settings"><a name="OMTG-CODE-009"></a>OMTG-CODE-009: Test Compiler Settings</h3>
<h4 id="overview-27">Overview</h4>
<p>Since most Android applications are Java based, they are <a href="https://www.owasp.org/index.php/Reviewing_Code_for_Buffer_Overruns_and_Overflows#.NET_.26_Java">immunue</a> to buffer overflow vulnerabilities.</p>
<h4 id="white-box-testing-29">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-29">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-26">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-30">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-010-verify-that-java-bytecode-has-been-minifed"><a name="OMTG-CODE-010"></a>OMTG-CODE-010: Verify that Java Bytecode Has Been Minifed</h3>
<h4 id="overview-28">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-30">White-box Testing</h4>
<p>Verify the minifyEnabled is set to true in build.gradle (see below).</p>
<h4 id="black-box-testing-30">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-27">Remediation</h4>
<p>ProGuard should be used to strip unneeded debugging information from the Java bytecode. By default, ProGuard removes attributes that are useful for debugging, including line numbers, source file names and variable names. ProGuard is a free Java class file shrinker, optimizer, obfuscator, and preverifier. It is shipped with Android’s SDK tools. To activate shrinking for the release build, add the following to build.gradle:</p>
<pre><code>android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(‘proguard-android.txt&#39;),
                    &#39;proguard-rules.pro&#39;
        }
    }
    ...
}</code></pre>
<h4 id="references-31">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-001-test-for-debugging-symbols-in-binaries"><a name="OMTG-RARE-001"></a>OMTG-RARE-001: Test for Debugging Symbols in Binaries</h3>
<h4 id="overview-29">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-31">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-31">Black-box Testing</h4>
<p>Symbols are usually stripped during the build process, so you need the compiled bytecode and libraries to verify whether the any unnecessary metadata has been discarded. For native binaries, use a standard tool like nm or objdump to inspect the symbol table. For example:</p>
<pre><code>berndt@osboxes:~/ $ objdump -t my_library.so
my_library.so:     file format elf32-little

SYMBOL TABLE:
no symbols</code></pre>
<p>Alternatively, open the file in your favorite disassembler and look for debugging symbols. For native libraries, it should be checked that the names of exports don’t give away the location of sensitive functions.</p>
<h4 id="remediation-28">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-32">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-002-test-for-meaningful-identifiers-in-java-bytecode"><a name="OMTG-RARE-002"></a>OMTG-RARE-002: Test for Meaningful Identifiers in Java Bytecode</h3>
<h4 id="overview-30">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-32">White-box Testing</h4>
<p>Verify the minifyEnabled is set to true in build.gradle (see below).</p>
<h4 id="black-box-testing-32">Black-box Testing</h4>
<p>To inspect the Java bytecode for metadata either use the dexdump tool that ships with the Android SDK or a decompiler.</p>
<p><img src="../images/proguard.jpg" alt="ProGuard-obfuscated code" /></p>
<h4 id="remediation-29">Remediation</h4>
<p>ProGuard should be used to strip unneeded debugging information from the Java bytecode. By default, ProGuard removes attributes that are useful for debugging, including line numbers, source file names and variable names. ProGuard is a free Java class file shrinker, optimizer, obfuscator, and preverifier. It is shipped with Android’s SDK tools. To activate shrinking for the release build, add the following to build.gradle:</p>
<pre><code>android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(‘proguard-android.txt&#39;),
                    &#39;proguard-rules.pro&#39;
        }
    }
    ...
}</code></pre>
<h4 id="references-33">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-003-test-jailbreak-root-detection"><a name="OMTG-RARE-003"></a>OMTG-RARE-003: Test Jailbreak / Root Detection</h3>
<h4 id="overview-31">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-33">White-box Testing</h4>
<p>Root detection is usually implemented as a number of environmental checks, such as checking for files and processes known to be found only on rooted devices, or artefacts of widely used rooting tools. If you have access to the source code, make sure that there is at least a check for the presence of the &quot;su&quot; binary in common locations, including:</p>
<pre><code>/system/bin/su
/system/xbin/su
/sbin/su</code></pre>
<p>It is also possible to check for app packages of typical rooting tools, such as Superuser.apk. However, the presence and location of these files varies heavily depending on the specific Android and tool version.</p>
<p>Another option is checking the list of installed apps against a package names of known rooting tools, such as:</p>
<pre><code>eu.chainfire.supersu
com.koushikdutta.superuser</code></pre>
<p>The package list can be obtained via the PackageManager:</p>
<pre><code>final PackageManager pm = getPackageManager();

List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);</code></pre>
<h4 id="black-box-testing-33">Black-box Testing</h4>
<p>Install the app on a rooted device and launch the app. If the app functions without any issues, then this test fails.</p>
<h4 id="references-34">References</h4>
<ul>
<li>Netspi Blog - <a href="https://blog.netspi.com/android-root-detection-techniques/" class="uri">https://blog.netspi.com/android-root-detection-techniques/</a></li>
<li>InfoSec Institute - <a href="http://resources.infosecinstitute.com/android-hacking-security-part-8-root-detection-evasion/" class="uri">http://resources.infosecinstitute.com/android-hacking-security-part-8-root-detection-evasion/</a></li>
</ul>
<h3 id="omtg-rare-004-test-verification-of-installation-source"><a name="OMTG-RARE-004"></a>OMTG-RARE-004: Test Verification of Installation Source</h3>
<h4 id="overview-32">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-34">White-box Testing</h4>
<h4 id="black-box-testing-34">Black-box Testing</h4>
<h4 id="references-35">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-005-test-simple-debugger-detection-prevention"><a name="OMTG-RARE-005"></a>OMTG-RARE-005: Test Simple Debugger Detection / Prevention</h3>
<h4 id="overview-33">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-35">White-box Testing</h4>
<h4 id="black-box-testing-35">Black-box Testing</h4>
<p>Attempt to attach a debugger to the running process. This should either fail, or the app should terminate or misbehave when the debugger has been detected. For example, if ptrace(PT_DENY_ATTACH) has been called, gdb will crash with a segmentation fault:</p>
<p>(TODO example)</p>
<p>(TODO JDWP)</p>
<p>Note that some anti-debugging implementations respond in a stealthy way so that changes in behaviour are not immediately apparent. For example, a soft token app might not visibly respond when a debugger is detected, but instead secretly alter the state of an internal variable so that an incorrect OTP is generated at a later point. Make sure to run through the complete workflow to determine if attaching the debugger causes a crash or malfunction.</p>
<h4 id="references-36">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-006-test-advanced-jailbreak-root-detection"><a name="OMTG-RARE-006"></a>OMTG-RARE-006: Test Advanced Jailbreak / Root Detection</h3>
<h4 id="overview-34">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-36">White-box Testing</h4>
<h4 id="black-box-testing-36">Black-box Testing</h4>
<h4 id="references-37">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-007-test-advanced-debugging-defenses"><a name="OMTG-RARE-007"></a>OMTG-RARE-007: Test Advanced Debugging Defenses</h3>
<h4 id="overview-35">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-37">White-box Testing</h4>
<h4 id="black-box-testing-37">Black-box Testing</h4>
<h4 id="references-38">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-008-test-file-tampering-detection"><a name="OMTG-RARE-008"></a>OMTG-RARE-008: Test File Tampering Detection</h3>
<h4 id="overview-36">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-38">White-box Testing</h4>
<h4 id="black-box-testing-38">Black-box Testing</h4>
<h4 id="references-39">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-009-test-detection-of-reverse-engineering-tools"><a name="OMTG-RARE-009"></a>OMTG-RARE-009: Test Detection of Reverse Engineering Tools</h3>
<h4 id="overview-37">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-39">White-box Testing</h4>
<h4 id="black-box-testing-39">Black-box Testing</h4>
<h4 id="references-40">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-010-test-basic-emulator-detection"><a name="OMTG-RARE-010"></a>OMTG-RARE-010: Test Basic Emulator Detection</h3>
<h4 id="overview-38">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-40">White-box Testing</h4>
<h4 id="black-box-testing-40">Black-box Testing</h4>
<h4 id="references-41">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-011-test-memory-tampering-detection"><a name="OMTG-RARE-011"></a>OMTG-RARE-011: Test Memory Tampering Detection</h3>
<h4 id="overview-39">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-41">White-box Testing</h4>
<h4 id="black-box-testing-41">Black-box Testing</h4>
<h4 id="references-42">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-012-test-variability-of-tampering-responses"><a name="OMTG-RARE-012"></a>OMTG-RARE-012: Test Variability of Tampering Responses</h3>
<h4 id="overview-40">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-42">White-box Testing</h4>
<h4 id="black-box-testing-42">Black-box Testing</h4>
<h4 id="references-43">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-013-test-binary-encryption"><a name="OMTG-RARE-013"></a>OMTG-RARE-013: Test Binary Encryption</h3>
<h4 id="overview-41">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-43">White-box Testing</h4>
<h4 id="black-box-testing-43">Black-box Testing</h4>
<h4 id="references-44">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-014-test-device-binding"><a name="OMTG-RARE-014"></a>OMTG-RARE-014: Test Device Binding</h3>
<h4 id="overview-42">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-44">White-box Testing</h4>
<h4 id="black-box-testing-44">Black-box Testing</h4>
<h4 id="references-45">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-015-test-advanced-jailbreak-root-detection"><a name="OMTG-RARE-015"></a>OMTG-RARE-015: Test Advanced Jailbreak / Root Detection</h3>
<h4 id="overview-43">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-45">White-box Testing</h4>
<h4 id="black-box-testing-45">Black-box Testing</h4>
<h4 id="references-46">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-016-test-advanced-emulator-detection"><a name="OMTG-RARE-016"></a>OMTG-RARE-016: Test Advanced Emulator Detection</h3>
<h4 id="overview-44">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-46">White-box Testing</h4>
<h4 id="black-box-testing-46">Black-box Testing</h4>
<h4 id="references-47">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-017-test-integration-of-se-andor-tee"><a name="OMTG-RARE-017"></a>OMTG-RARE-017: Test Integration of SE and/or TEE</h3>
<h4 id="overview-45">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-47">White-box Testing</h4>
<h4 id="black-box-testing-47">Black-box Testing</h4>
<h4 id="references-48">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-rare-018-test-advanced-obfuscation"><a name="OMTG-RARE-018"></a>OMTG-RARE-018: Test Advanced Obfuscation</h3>
<h4 id="overview-46">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-48">White-box Testing</h4>
<h4 id="black-box-testing-48">Black-box Testing</h4>
<h4 id="references-49">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-datast-002-test-for-sensitive-data-disclosure-in-log-files-1"><a name="OMTG-DATAST-002"></a>OMTG-DATAST-002: Test for Sensitive Data Disclosure in Log Files</h3>
<h4 id="overview-47">Overview</h4>
<p>There are many legit reasons to create log files on a mobile device, for example to keep track of crashes or errors that are stored locally when being offline and being sent to the application developer/company once online again or for usage statistics. However, logging sensitive data such as credit card number and session IDs might expose the data to attackers or malicious applications.<br />
Log files can be created in various ways on each of the different operating systems. The following list shows the mechanisms that are available on iOS:</p>
<ul>
<li>NSLog Method</li>
<li>printf-like function</li>
<li>NSAssert-like function</li>
<li>Macro</li>
</ul>
<p>Classification of sensitive information can vary between different industries, countries and their laws and regulations. Therefore laws and regulations need to be known that are applicable to it and to be aware of what sensitive information actually is in the context of the App.</p>
<h4 id="black-box-testing-49">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="white-box-testing-49">White-box Testing</h4>
<p>Check the source code for usage of predefined/custom Logging statements using the following keywords :</p>
<ul>
<li>For predefined and built-in functions :</li>
<li>NSLog</li>
<li>NSAssert</li>
<li>NSCAssert</li>
<li>fprintf</li>
<li>For custom functions :</li>
<li>Logging</li>
<li>Logfile</li>
</ul>
<h4 id="remediation-30">Remediation</h4>
<p>Use a define to enable NSLog statements for development and debugging, and disable these before shipping the software. This can be done by putting the following code into the appropriate PREFIX_HEADER (*.pch) file:</p>
<pre class="c#"><code>#ifdef DEBUG
#   define NSLog (...) NSLog(__VA_ARGS__)
#else
#   define NSLog (...)
#endif</code></pre>
<h4 id="references-50">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-datast-010-test-for-sensitive-data-in-the-backgrounded-app-2"><a name="OMTG-DATAST-010"></a>OMTG-DATAST-010: Test for Sensitive Data in the Backgrounded App</h3>
<h4 id="overview-48">Overview</h4>
<p>Manufacturers want to provide device users an aesthetically pleasing effect when an application is entered or exited, hence they introduced the concept of saving a screenshot when the application goes into the background. This feature could potentially pose a security risk for an application, as the screenshot containing sensitive information (e.g. a screenshot of an email or corporate documents) is written to local storage, where it is recovered either by a rogue application on a jailbroken device, or by someone who steals the device.</p>
<h4 id="black-box-testing-50">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="white-box-testing-50">White-box Testing</h4>
<p>While analyzing the source code, look for the fields or screens where sensitive data is involved. Identify if the application sanitize the screen before being backgrounded.</p>
<h4 id="remediation-31">Remediation</h4>
<p>The application must obsucate/hide any sensitive informations before being backgrouded, either by bluring the screen (e.g. using GPUImageiOSBlurFilter) or overriding the current view in the applicationDidEnterBackground state transition method.</p>
<h4 id="references-51">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-identifiername-3"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h3>
<h4 id="overview-49">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-51">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-51">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-32">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-52">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-identifiername-4"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h3>
<h4 id="overview-50">Overview</h4>
<p>(Give an overview about the functionality and it's potential weaknesses)</p>
<h4 id="white-box-testing-52">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-52">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-33">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-53">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h2 id="omtg-net-004-testing-ssl-pinning-2"><a name="OMTG-NET-004"></a>OMTG-NET-004: Testing SSL Pinning</h2>
<h3 id="white-box-testing-53">White-box Testing</h3>
<p>The code presented below shows how it is possible to check if the certificate provided by the server reflects the certificate hard-coded in the application. The method below implements the connection authentication tells the delegate that the connection will send a request for an authentication challenge.</p>
<p>The delegate must implement connection:canAuthenticateAgainstProtectionSpace: and connection: forAuthenticationChallenge. Within connection: forAuthenticationChallenge, the delegate must call SecTrustEvaluate to perform customary X509 checks. Below a snippet who implements a check of the certificate.</p>
<pre class="objective-c"><code>(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, 0);
NSData *remoteCertificateData = CFBridgingRelease(SecCertificateCopyData(certificate));
NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;MyLocalCertificate&quot; ofType:@&quot;cer&quot;];
NSData *localCertData = [NSData dataWithContentsOfFile:cerPath];
The control below can verify if the certificate received by the server is matching the one pinned in the client.
if ([remoteCertificateData isEqualToData:localCertData]) {
NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
[[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];
}
else {
[[challenge sender] cancelAuthenticationChallenge:challenge];
}</code></pre>
<h3 id="black-box-testing-53">Black-box Testing</h3>
<p>Dynamic analysis can be done by following the same methodology used for the Android applications.</p>
<h3 id="remediation-34">Remediation</h3>
<p>The SSL pinning process should be implemented as described on the static analysis section.</p>
<h3 id="references-54">References</h3>
<ul>
<li>Setting Burp Suite as a proxy for iOS Devices : <a href="https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp" class="uri">https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp</a><br />
References</li>
<li>OWASP - Certificate Pinning for iOS : <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#iOS" class="uri">https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#iOS</a></li>
</ul>
<h2 id="omtg-identifiername-5"><a name="[Anchor, e.g.: OMTG-DATAST-001]"></a>OMTG-[IDENTIFIER]:[Name]</h2>
<h3 id="owasp-mobile-top-10-14">OWASP Mobile Top 10</h3>
<p>M[ID] - [Title]</p>
<h3 id="cwe-14">CWE</h3>
<p>CWE [ID] - [Title]</p>
<h3 id="white-box-testing-54">White-box Testing</h3>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h3 id="black-box-testing-54">Black-box Testing</h3>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h3 id="remediation-35">Remediation</h3>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h3 id="references-55">References</h3>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-001-verify-that-the-app-is-properly-signed"><a name="OMTG-CODE-001"></a>OMTG-CODE-001: Verify that the App is Properly Signed</h3>
<h4 id="white-box-testing-55">White-box Testing</h4>
<h4 id="black-box-testing-55">Black-box Testing</h4>
<h4 id="remediation-36">Remediation</h4>
<h4 id="references-56">References</h4>
<h5 id="owasp-masvs-14">OWASP MASVS</h5>
<ul>
<li>V7.1: &quot;The app is signed and provisioned with valid certificate.&quot;</li>
</ul>
<h3 id="omtg-code-002-test-whether-the-app-is-debuggable-1"><a name="OMTG-CODE-002"></a>OMTG-CODE-002: Test whether the App is Debuggable</h3>
<h4 id="white-box-testing-56">White-box Testing</h4>
<ol>
<li>Import the source code into the xCode Editor.</li>
<li>Check the project's build settings for 'DEBUG' parameter under &quot;Apple LVM – Preprocessing&quot; -&gt; &quot;Preprocessor Macros&quot;.</li>
<li>Check the source code for NSAsserts method and its companions.</li>
</ol>
<h4 id="black-box-testing-56">Black-box Testing</h4>
<p>This test case should be performed during White-box testing.</p>
<h4 id="remediation-37">Remediation</h4>
<p>Once you have deployed an iOS application, either through the App Store or as an Ad Hoc or Enterprise build, you won't be able to attach Xcode's debugger to it. To debug problems, you need to analyze Crash Logs and Console output from the device itself. Remove any NSLog calls to prevent debug leakage through the Console.</p>
<h4 id="references-57">References</h4>
<p>(TODO)</p>
<h3 id="omtg-code-003-verify-that-debugging-symbols-have-been-removed-1"><a name="OMTG-CODE-003"></a>OMTG-CODE-003: Verify that Debugging Symbols Have Been Removed</h3>
<h4 id="white-box-testing-57">White-box Testing</h4>
<p>Review the source code to understand/identify who the application handle various types of errors (IPC communications, remote services invokation, etc). Here are some examples of the checks to be performed at this stage :</p>
<ul>
<li>Verify that the application use a [well-designed] (<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047" class="uri">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047</a>) (an unified) scheme to handle exceptions.</li>
<li>Verify that the application doesn't expose sensitive information while handeling exceptions, but are still verbose enough to explain the issue to the user.</li>
<li>C3</li>
</ul>
<h4 id="black-box-testing-57">Black-box Testing</h4>
<p>Symbols are usually stripped during the build process, so you need the compiled bytecode and libraries to verify whether the any unnecessary metadata has been discarded. For native binaries, use a standard tool like nm or objdump to inspect the symbol table. For example:</p>
<pre><code>berndt@osboxes:~/ $ objdumpApplication Security Verification Standard -t my_library.so
my_library.so:     file format elf32-little

SYMBOL TABLE:
no symbols</code></pre>
<p>Alternatively, open the file in your favorite disassembler and look for debugging symbols. For native libraries, it should be checked that the names of exports don’t give away the location of sensitive functions.</p>
<h4 id="remediation-38">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-58">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-004-test-for-debugging-code-and-verbose-error-logging-1"><a name="OMTG-CODE-004"></a>OMTG-CODE-004: Test for Debugging Code and Verbose Error Logging</h3>
<h4 id="white-box-testing-58">White-box Testing</h4>
<h4 id="black-box-testing-58">Black-box Testing</h4>
<h4 id="remediation-39">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-59">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-005-test-exception-handling-1"><a name="OMTG-CODE-005"></a>OMTG-CODE-005: Test Exception Handling</h3>
<h4 id="white-box-testing-59">White-box Testing</h4>
<p>Review the source code to understand/identify who the application handle various types of errors (IPC communications, remote services invokation, etc). Here are some examples of the checks to be performed at this stage :</p>
<ul>
<li>Verify that the application use a [well-designed] (<a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047" class="uri">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18581047</a>) (an unified) scheme to handle exceptions.</li>
<li>Verify that the application doesn't expose sensitive information while handeling exceptions, but are still verbose enough to explain the issue to the user.</li>
<li>C3</li>
</ul>
<h4 id="black-box-testing-59">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-40">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-60">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-006-verify-that-the-app-fails-securely-1"><a name="OMTG-CODE-006"></a>OMTG-CODE-006: Verify that the App Fails Securely</h3>
<h4 id="white-box-testing-60">White-box Testing</h4>
<h4 id="black-box-testing-60">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-41">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-61">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-007-test-input-validation-1"><a name="OMTG-CODE-007"></a>OMTG-CODE-007: Test Input Validation</h3>
<h4 id="white-box-testing-61">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-61">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-42">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-62">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-008-test-memory-management-1"><a name="OMTG-CODE-008"></a>OMTG-CODE-008: Test Memory Management</h3>
<h4 id="white-box-testing-62">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-62">Black-box Testing</h4>
<p>[Describe how to test for this issue using static and dynamic analysis techniques. This can include everything from simply monitoring aspects of the app’s behavior to code injection, debugging, instrumentation, etc. ]</p>
<h4 id="remediation-43">Remediation</h4>
<p>[Describe the best practices that developers should follow to prevent this issue]</p>
<h4 id="references-63">References</h4>
<ul>
<li>[link to relevant how-tos, papers, etc.]</li>
</ul>
<h3 id="omtg-code-009-test-compiler-settings-1"><a name="OMTG-CODE-009"></a>OMTG-CODE-009: Test Compiler Settings</h3>
<h4 id="white-box-testing-63">White-box Testing</h4>
<p>(Describe how to assess this with access to the source code and build configuration)</p>
<h4 id="black-box-testing-63">Black-box Testing</h4>
<h5 id="with-otool">With otool :</h5>
<ul>
<li>Check if the stack smashing protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep stack</code></pre>
<p>If the application was compiled with the stack smashing protection two undefined symbols will be present: &quot;_<strong>stack_chk_fail&quot; and &quot;</strong>_stack_chk_guard&quot;.</p>
<ul>
<li>Check the PIE protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep PIE</code></pre>
<p>If the above command emit no output then the PIE protection isn't enabled.</p>
<ul>
<li>Check the ACR protection is enabled :</li>
</ul>
<pre><code>$ otool -Iv &lt;app name&gt; | grep _objc_release</code></pre>
<p>If the above command emit no output then the ACR protection isn't enabled.</p>
<h5 id="with-idb">With idb :</h5>
<p>IDB automates the process of checking for both stack canary and PIE support. Select the target binary in the IDB gui and click the &quot;Analyze Binary…&quot; button.</p>
<p><img src="https://github.com/OWASP/owasp-mstg/blob/master/Document/images/idb.png" alt="alt tag" /></p>
<h4 id="remediation-44">Remediation</h4>
<ul>
<li>Stack smashing protection</li>
</ul>
<p>Steps for enabling Stack smashing protection within an iOS application :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>Verify that &quot;–fstack-protector-all&quot; option is selected under &quot;Other C Flags&quot; section.</li>
</ol>
<ul>
<li>PIE support</li>
</ul>
<p>Steps for building an iOS application as PIE :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>For iOS apps, set iOS Deployment Target to iOS 4.3 or later. For Mac apps, set OS X Deployment Target to OS X 10.7 or later.</li>
<li>Verify that &quot;Generate Position-Dependent Code&quot; is set at its default value of NO.</li>
<li>Verify that Don't &quot;Create Position Independent Executables&quot; is set at its default value of NO.</li>
</ol>
<ul>
<li>ARC protection</li>
</ul>
<p>Steps for enabling ACR protection within an iOS application :</p>
<ol>
<li>In Xcode, select your target in the &quot;Targets&quot; section, then click the &quot;Build Settings&quot; tab to view its settings.</li>
<li>Verify that &quot;Objective-C Automatic Reference Counting&quot; is set at its default value of YES.</li>
</ol>
<h4 id="references-64">References</h4>
<ul>
<li>Technical Q&amp;A QA1788 Building a Position Independent Executable : <a href="https://developer.apple.com/library/mac/qa/qa1788/_index.html" class="uri">https://developer.apple.com/library/mac/qa/qa1788/_index.html</a></li>
<li>idb : <a href="https://github.com/dmayer/idb" class="uri">https://github.com/dmayer/idb</a></li>
</ul>
<h3 id="omtg-code-010-verify-that-java-bytecode-has-been-minifed-1"><a name="OMTG-CODE-010"></a>OMTG-CODE-010: Verify that Java Bytecode Has Been Minifed</h3>
<p>Not applicable on iOS.</p>
<h3 id="omtg-rare-001-test-the-custom-keyboard-1"><a name="OMTG-RARE-001"></a>OMTG-RARE-001: Test the Custom Keyboard</h3>
<h4 id="white-box-testing-64">White-box Testing</h4>
<h4 id="black-box-testing-64">Black-box Testing</h4>
<h4 id="references-65">References</h4>
<h3 id="omtg-rare-001-test-the-custom-keyboard-2">OMTG-RARE-001: Test the Custom Keyboard</h3>
<h4 id="detailed-guides-1">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-001">OMTG-RARE-001 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-001">OMTG-RARE-001 iOS</a></li>
</ul>
<h4 id="references-66">References</h4>
<ul>
<li>OWASP MASVS: V9-1: &quot;The app provides a custom keyboard whenever sensitive data is entered.&quot;</li>
<li>CWE: N/A</li>
</ul>
<h3 id="omtg-rare-002-test-for-sensitive-data-in-ui-components-1">OMTG-RARE-002: Test for Sensitive Data in UI Components</h3>
<h4 id="detailed-guides-2">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-002">OMTG-RARE-002 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-002">OMTG-RARE-002 iOS</a></li>
</ul>
<h4 id="references-67">References</h4>
<ul>
<li>OWASP MASVS: V9-2: &quot;Custom UI components are used to display sensitive data. The UI components should not rely on immutable data structures.&quot;</li>
<li>CWE: N/A</li>
</ul>
<h3 id="omtg-rare-003-test-advanced-jailbreak-root-detection-1">OMTG-RARE-003: Test Advanced Jailbreak / Root Detection</h3>
<h4 id="detailed-guides-3">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-003">OMTG-RARE-003 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-003">OMTG-RARE-003 iOS</a></li>
</ul>
<h4 id="references-68">References</h4>
<ul>
<li>OWASP MASVS : V9.3: &quot;Verify that the app implements two or more functionally independent methods of root detection and responds to the presence of a rooted device either by alerting the user or terminating the app.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-004-test-advanced-debugging-defenses-1">OMTG-RARE-004: Test Advanced Debugging Defenses</h3>
<h4 id="detailed-guides-4">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-004">OMTG-RARE-004 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-004">OMTG-RARE-004 iOS</a></li>
</ul>
<h4 id="references-69">References</h4>
<ul>
<li>OWASP MASVS : V9.4: &quot;The app implements multiple functionally independent debugging defenses that, in context of the overall protection scheme, force adversaries to invest significant manual effort to enable debugging. All available debugging protocols must be covered (e.g. JDWP and native).&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-005-test-file-tampering-detection-1">OMTG-RARE-005: Test File Tampering Detection</h3>
<h4 id="detailed-guides-5">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-005">OMTG-RARE-005 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-005">OMTG-RARE-005 iOS</a></li>
</ul>
<h4 id="references-70">References</h4>
<ul>
<li>OWASP MASVS : V9.5: &quot;Verify that the app detects and responds to tampering with executable files and critical data.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-006-test-detection-of-reverse-engineering-tools-1">OMTG-RARE-006: Test Detection of Reverse Engineering Tools</h3>
<h4 id="detailed-guides-6">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-006">OMTG-RARE-006 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-006">OMTG-RARE-006 iOS</a></li>
</ul>
<h4 id="references-71">References</h4>
<ul>
<li>OWASP MASVS : V9.6: &quot;The app detects the presence of widely used reverse engineering tools, such as code injection tools, hooking frameworks and debugging servers.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-007-test-basic-emulator-detection-1">OMTG-RARE-007: Test Basic Emulator Detection</h3>
<h4 id="detailed-guides-7">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-007">OMTG-RARE-007 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-007">OMTG-RARE-007 iOS</a></li>
</ul>
<h4 id="references-72">References</h4>
<ul>
<li>OWASP MASVS : V9.7: &quot;The app detects, and responds to, being run in an emulator using any method.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-008-test-memory-tampering-detection-1">OMTG-RARE-008: Test Memory Tampering Detection</h3>
<h4 id="detailed-guides-8">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-008">OMTG-RARE-008 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-008">OMTG-RARE-008 iOS</a></li>
</ul>
<h4 id="references-73">References</h4>
<ul>
<li>OWASP MASVS : V9.8: &quot;The app detects, and responds to, modifications of process memory, including relocation table patches and injected code.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-009-test-variability-of-tampering-responses-1">OMTG-RARE-009: Test Variability of Tampering Responses</h3>
<h4 id="detailed-guides-9">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-009">OMTG-RARE-009 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-009">OMTG-RARE-009 iOS</a></li>
</ul>
<h4 id="references-74">References</h4>
<ul>
<li>OWASP MASVS : V9.9: &quot;The app implements multiple different responses to tampering, debugging and emulation, including stealthy responses that don't simply terminate the app..&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-010-test-binary-encryption-1">OMTG-RARE-010: Test Binary Encryption</h3>
<h4 id="detailed-guides-10">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-010">OMTG-RARE-010 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-010">OMTG-RARE-010 iOS</a></li>
</ul>
<h4 id="references-75">References</h4>
<ul>
<li>OWASP MASVS : V9.10: &quot;All executable files and libraries belonging to the app are either encrypted on the file level and/or important code and data segments inside the executables are encrypted or packed. Trivial static analysis should not reveal important code or data.&quot;</li>
<li>CWE : N/A</li>
</ul>
<h3 id="omtg-rare-014-test-device-binding-1">OMTG-RARE-014: Test Device Binding</h3>
<h4 id="detailed-guides-11">Detailed Guides</h4>
<ul>
<li><a href="0x06a_OMTG-RARE_Android.md#OMTG-RARE-011">OMTG-RARE-011 Android</a></li>
<li><a href="0x06b_OMTG-RARE_iOS.md#OMTG-RARE-011">OMTG-RARE-011 iOS</a></li>
</ul>
<h4 id="references-76">References</h4>
<ul>
<li>OWASP MASVS : V9.11: &quot;Obfuscating transformations and functional defenses are interdependent and well-integrated throughout the app.&quot;</li>
<li>CWE : N/A</li>
</ul>
<p>(... TODO ...)</p>
